#pragma version 10

contract.SlotMachine.approval_program:
    txn ApplicationID
    bnz main_entrypoint@2
    callsub __init__

main_entrypoint@2:
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txn NumAppArgs
    bz main_bare_routing@29
    method "post_upgrade()void"
    method "set_min_bank_amount(uint64)void"
    method "set_payout_model(uint64)void"
    method "set_min_bet_amount(uint64)void"
    method "set_max_bet_amount(uint64)void"
    method "burn_upgreadable_fuse()void"
    method "burn_stakeable_fuse()void"
    method "burn_deletable_fuse()void"
    method "deposit()void"
    method "withdraw(uint64)void"
    method "get_balance_available()uint64"
    method "get_balance_locked()uint64"
    method "get_balance_total()uint64"
    method "get_bet_key(address,uint64,uint64,uint64)byte[56]"
    method "kill()void"
    method "spin(uint64,uint64)byte[56]"
    method "claim(byte[56])uint64"
    method "set_version(uint64,uint64)void"
    method "approve_update(bool)void"
    method "grant_upgrader(address)void"
    method "set_delegate(address)void"
    method "participate(byte[32],byte[32],uint64,uint64,uint64,byte[64])void"
    method "transfer(address)void"
    txna ApplicationArgs 0
    match main_post_upgrade_route@4 main_set_min_bank_amount_route@5 main_set_payout_model_route@6 main_set_min_bet_amount_route@7 main_set_max_bet_amount_route@8 main_burn_upgreadable_fuse_route@9 main_burn_stakeable_fuse_route@10 main_burn_deletable_fuse_route@11 main_deposit_route@12 main_withdraw_route@13 main_get_balance_available_route@14 main_get_balance_locked_route@15 main_get_balance_total_route@16 main_get_bet_key_route@17 main_kill_route@18 main_spin_route@19 main_claim_route@20 main_set_version_route@21 main_approve_update_route@22 main_grant_upgrader_route@23 main_set_delegate_route@24 main_participate_route@25 main_transfer_route@26
    err // reject transaction

main_post_upgrade_route@4:
    // src/src/contract.py:398
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub post_upgrade
    int 1
    return

main_set_min_bank_amount_route@5:
    // src/src/contract.py:409
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:409
    // @arc4.abimethod
    callsub set_min_bank_amount
    int 1
    return

main_set_payout_model_route@6:
    // src/src/contract.py:418
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:418
    // @arc4.abimethod
    callsub set_payout_model
    int 1
    return

main_set_min_bet_amount_route@7:
    // src/src/contract.py:427
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:427
    // @arc4.abimethod
    callsub set_min_bet_amount
    int 1
    return

main_set_max_bet_amount_route@8:
    // src/src/contract.py:439
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:439
    // @arc4.abimethod
    callsub set_max_bet_amount
    int 1
    return

main_burn_upgreadable_fuse_route@9:
    // src/src/contract.py:451
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub burn_upgreadable_fuse
    int 1
    return

main_burn_stakeable_fuse_route@10:
    // src/src/contract.py:459
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub burn_stakeable_fuse
    int 1
    return

main_burn_deletable_fuse_route@11:
    // src/src/contract.py:467
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub burn_deletable_fuse
    int 1
    return

main_deposit_route@12:
    // src/src/contract.py:483
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub deposit
    int 1
    return

main_withdraw_route@13:
    // src/src/contract.py:493
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:493
    // @arc4.abimethod
    callsub withdraw
    int 1
    return

main_get_balance_available_route@14:
    // src/src/contract.py:511
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub get_balance_available
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_get_balance_locked_route@15:
    // src/src/contract.py:518
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub get_balance_locked
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_get_balance_total_route@16:
    // src/src/contract.py:525
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub get_balance_total
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_get_bet_key_route@17:
    // src/src/contract.py:534
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // src/src/contract.py:534
    // @arc4.abimethod(readonly=True)
    callsub get_bet_key
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_kill_route@18:
    // src/src/contract.py:559
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    txn OnCompletion
    int DeleteApplication
    ==
    assert // OnCompletion is DeleteApplication
    txn ApplicationID
    assert // is not creating
    callsub kill
    int 1
    return

main_spin_route@19:
    // src/src/contract.py:300
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // src/src/contract.py:300
    // @arc4.abimethod
    callsub spin
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_claim_route@20:
    // src/src/contract.py:332
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:332
    // @arc4.abimethod
    callsub claim
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_set_version_route@21:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83
    // @arc4.abimethod
    callsub set_version
    int 1
    return

main_approve_update_route@22:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101
    // @arc4.abimethod
    callsub approve_update
    int 1
    return

main_grant_upgrader_route@23:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107
    // @arc4.abimethod
    callsub grant_upgrader
    int 1
    return

main_set_delegate_route@24:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:81
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:81
    // @arc4.abimethod
    callsub set_delegate
    int 1
    return

main_participate_route@25:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:89
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:89
    // @arc4.abimethod
    callsub participate
    int 1
    return

main_transfer_route@26:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:22
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    int 1
    return

main_bare_routing@29:
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txn OnCompletion
    switch main_create@30 main_reject_bare_on_completion@33 main_reject_bare_on_completion@33 main_reject_bare_on_completion@33 main_on_update@31 main_on_delete@32
    err // reject transaction

main_create@30:
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    txn ApplicationID
    !
    assert // is creating
    int 1
    return

main_on_update@31:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    txn ApplicationID
    assert // is not creating
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92-93
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def on_update(self) -> None:
    callsub on_update
    int 1
    return

main_on_delete@32:
    // src/src/contract.py:58
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:58-59
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    // def on_delete(self) -> None:  # pragma: no cover
    callsub on_delete
    int 1
    return

main_reject_bare_on_completion@33:
    // src/src/contract.py:359
    // class SlotMachine(SlotMachineInterface, Upgradeable, Stakeable, Deleteable):
    err // reject transaction


// contract.SlotMachine.post_upgrade() -> void:
post_upgrade:
    // src/src/contract.py:398-399
    // @arc4.abimethod
    // def post_upgrade(self) -> None:
    proto 0 0
    // src/src/contract.py:403
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:403
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // src/src/contract.py:404
    // self.contract_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // src/src/contract.py:405
    // self.deployment_version = UInt64()
    int 0
    app_global_put
    retsub


// contract.SlotMachine.set_min_bank_amount(min_bank_amount: bytes) -> void:
set_min_bank_amount:
    // src/src/contract.py:409-410
    // @arc4.abimethod
    // def set_min_bank_amount(self, min_bank_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:414
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:415
    // assert min_bank_amount.native >= MIN_BANK_AMOUNT, "min bank amount must be greater than 350,000 VOI"
    frame_dig -1
    btoi
    dup
    int 350000000000
    >=
    assert // min bank amount must be greater than 350,000 VOI
    // src/src/contract.py:383
    // self.min_bank_amount = UInt64(MIN_BANK_AMOUNT)  # 350,000 VOI
    byte "min_bank_amount"
    // src/src/contract.py:416
    // self.min_bank_amount = min_bank_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.only_owner() -> void:
only_owner:
    // src/src/contract.py:389-390
    // @subroutine
    // def only_owner(self) -> None:
    proto 0 0
    // src/src/contract.py:394
    // assert Txn.sender == self.owner, "only owner can call this function"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // src/src/contract.py:394
    // assert Txn.sender == self.owner, "only owner can call this function"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // only owner can call this function
    retsub


// contract.SlotMachine.set_payout_model(app_id: bytes) -> void:
set_payout_model:
    // src/src/contract.py:418-419
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:423
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:424
    // assert app_id.native > 0, "app id must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // app id must be greater than 0
    // src/src/contract.py:384
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    // src/src/contract.py:425
    // self.payout_model = app_id.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.set_min_bet_amount(min_bet_amount: bytes) -> void:
set_min_bet_amount:
    // src/src/contract.py:427-428
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:432
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:433
    // assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // min bet amount must be greater than 0
    // src/src/contract.py:435
    // min_bet_amount.native <= self.max_bet_amount
    int 0
    // src/src/contract.py:382
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:435
    // min_bet_amount.native <= self.max_bet_amount
    app_global_get_ex
    assert // check self.max_bet_amount exists
    dig 1
    >=
    // src/src/contract.py:434-436
    // assert (
    //     min_bet_amount.native <= self.max_bet_amount
    // ), "min bet amount must be less than max bet amount"
    assert // min bet amount must be less than max bet amount
    // src/src/contract.py:381
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:437
    // self.min_bet_amount = min_bet_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.set_max_bet_amount(max_bet_amount: bytes) -> void:
set_max_bet_amount:
    // src/src/contract.py:439-440
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:444
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:445
    // assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // max bet amount must be greater than 0
    // src/src/contract.py:447
    // max_bet_amount.native >= self.min_bet_amount
    int 0
    // src/src/contract.py:381
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:447
    // max_bet_amount.native >= self.min_bet_amount
    app_global_get_ex
    assert // check self.min_bet_amount exists
    dig 1
    <=
    // src/src/contract.py:446-448
    // assert (
    //     max_bet_amount.native >= self.min_bet_amount
    // ), "max bet amount must be greater than min bet amount"
    assert // max bet amount must be greater than min bet amount
    // src/src/contract.py:382
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:449
    // self.max_bet_amount = max_bet_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.burn_upgreadable_fuse() -> void:
burn_upgreadable_fuse:
    // src/src/contract.py:451-452
    // @arc4.abimethod
    // def burn_upgreadable_fuse(self) -> None:
    proto 0 0
    // src/src/contract.py:456
    // self.only_owner()
    callsub only_owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:457
    // self.updatable = False
    int 0
    app_global_put
    retsub


// contract.SlotMachine.burn_stakeable_fuse() -> void:
burn_stakeable_fuse:
    // src/src/contract.py:459-460
    // @arc4.abimethod
    // def burn_stakeable_fuse(self) -> None:
    proto 0 0
    // src/src/contract.py:464
    // self.only_owner()
    callsub only_owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:48
    // self.stakeable = bool(1)
    byte "stakeable"
    // src/src/contract.py:465
    // self.stakeable = False
    int 0
    app_global_put
    retsub


// contract.SlotMachine.burn_deletable_fuse() -> void:
burn_deletable_fuse:
    // src/src/contract.py:467-468
    // @arc4.abimethod
    // def burn_deletable_fuse(self) -> None:
    proto 0 0
    // src/src/contract.py:472
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:473
    // self.deletable = False
    int 0
    app_global_put
    retsub


// contract.SlotMachine.deposit() -> void:
deposit:
    // src/src/contract.py:483-484
    // @arc4.abimethod
    // def deposit(self) -> None:
    proto 0 0
    // src/src/contract.py:488
    // payment = require_payment(Txn.sender)
    txn Sender
    callsub require_payment
    // src/src/contract.py:489
    // assert payment > 0, "payment must be greater than 0"
    dup
    assert // payment must be greater than 0
    // src/src/contract.py:490
    // self.balance_total += payment
    int 0
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:490
    // self.balance_total += payment
    app_global_get_ex
    assert // check self.balance_total exists
    dig 1
    +
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:490
    // self.balance_total += payment
    swap
    app_global_put
    // src/src/contract.py:491
    // self.balance_available += payment
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:491
    // self.balance_available += payment
    app_global_get_ex
    assert // check self.balance_available exists
    +
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:491
    // self.balance_available += payment
    swap
    app_global_put
    retsub


// opensubmarine.utils.algorand.require_payment(who: bytes) -> uint64:
require_payment:
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:15-23
    // ##############################################
    // # function: require_payment (internal)
    // # arguments: None
    // # purpose: check payment
    // # pre-conditions: None
    // # post-conditions: None
    // ##############################################
    // @subroutine
    // def require_payment(who: Account) -> UInt64:
    proto 1 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:24
    // ref_group_index = Txn.group_index
    txn GroupIndex
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:25
    // assert ref_group_index > 0, "group index greater than zero"
    dup
    assert // group index greater than zero
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:26
    // payment_group_index = ref_group_index - 1
    int 1
    -
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:28
    // gtxn.PaymentTransaction(payment_group_index).sender == who
    dup
    gtxns TypeEnum
    int pay
    ==
    assert // transaction type is pay
    dup
    gtxns Sender
    frame_dig -1
    ==
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:27-29
    // assert (
    //     gtxn.PaymentTransaction(payment_group_index).sender == who
    // ), "payment sender accurate"
    assert // payment sender accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:31
    // gtxn.PaymentTransaction(payment_group_index).receiver
    dup
    gtxns Receiver
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:32
    // == Global.current_application_address
    global CurrentApplicationAddress
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:31-32
    // gtxn.PaymentTransaction(payment_group_index).receiver
    // == Global.current_application_address
    ==
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:30-33
    // assert (
    //     gtxn.PaymentTransaction(payment_group_index).receiver
    //     == Global.current_application_address
    // ), "payment receiver accurate"
    assert // payment receiver accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:34
    // return gtxn.PaymentTransaction(payment_group_index).amount
    gtxns Amount
    retsub


// contract.SlotMachine.withdraw(amount: bytes) -> void:
withdraw:
    // src/src/contract.py:493-494
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:502
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:503
    // assert amount.native > UInt64(0), "amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // amount must be greater than 0
    // src/src/contract.py:504
    // assert amount.native <= self.balance_available, "insufficient balance"
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:504
    // assert amount.native <= self.balance_available, "insufficient balance"
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    >=
    assert // insufficient balance
    // src/src/contract.py:505
    // itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    itxn_begin
    txn Sender
    dig 1
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:506
    // self.balance_available -= amount.native
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:506
    // self.balance_available -= amount.native
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    -
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:506
    // self.balance_available -= amount.native
    swap
    app_global_put
    // src/src/contract.py:507
    // self.balance_total -= amount.native
    int 0
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:507
    // self.balance_total -= amount.native
    app_global_get_ex
    assert // check self.balance_total exists
    swap
    -
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:507
    // self.balance_total -= amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.get_balance_available() -> bytes:
get_balance_available:
    // src/src/contract.py:511-512
    // @arc4.abimethod(readonly=True)
    // def get_balance_available(self) -> arc4.UInt64:
    proto 0 1
    // src/src/contract.py:516
    // return arc4.UInt64(self.balance_available)
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:516
    // return arc4.UInt64(self.balance_available)
    app_global_get_ex
    assert // check self.balance_available exists
    itob
    retsub


// contract.SlotMachine.get_balance_locked() -> bytes:
get_balance_locked:
    // src/src/contract.py:518-519
    // @arc4.abimethod(readonly=True)
    // def get_balance_locked(self) -> arc4.UInt64:
    proto 0 1
    // src/src/contract.py:523
    // return arc4.UInt64(self.balance_locked)
    int 0
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:523
    // return arc4.UInt64(self.balance_locked)
    app_global_get_ex
    assert // check self.balance_locked exists
    itob
    retsub


// contract.SlotMachine.get_balance_total() -> bytes:
get_balance_total:
    // src/src/contract.py:525-526
    // @arc4.abimethod(readonly=True)
    // def get_balance_total(self) -> arc4.UInt64:
    proto 0 1
    // src/src/contract.py:530
    // return arc4.UInt64(self.balance_total)
    int 0
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:530
    // return arc4.UInt64(self.balance_total)
    app_global_get_ex
    assert // check self.balance_total exists
    itob
    retsub


// contract.SlotMachine.get_bet_key(address: bytes, amount: bytes, round: bytes, index: bytes) -> bytes:
get_bet_key:
    // src/src/contract.py:534-541
    // @arc4.abimethod(readonly=True)
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    proto 4 1
    // src/src/contract.py:543
    // self._get_bet_key(address.native, amount.native, round.native, index.native)
    frame_dig -3
    btoi
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    frame_dig -4
    cover 3
    callsub _get_bet_key
    // src/src/contract.py:542-544
    // return Bytes56.from_bytes(
    //     self._get_bet_key(address.native, amount.native, round.native, index.native)
    // )
    retsub


// contract.SlotMachine._get_bet_key(address: bytes, amount: uint64, round: uint64, index: uint64) -> bytes:
_get_bet_key:
    // src/src/contract.py:546-549
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    proto 4 1
    // src/src/contract.py:552
    // + arc4.UInt64(amount).bytes
    frame_dig -3
    itob
    // src/src/contract.py:551-552
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    frame_dig -4
    swap
    concat
    // src/src/contract.py:553
    // + arc4.UInt64(round).bytes
    frame_dig -2
    itob
    // src/src/contract.py:551-553
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    // + arc4.UInt64(round).bytes
    concat
    // src/src/contract.py:554
    // + arc4.UInt64(index).bytes
    frame_dig -1
    itob
    // src/src/contract.py:551-554
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    // + arc4.UInt64(round).bytes
    // + arc4.UInt64(index).bytes
    concat
    // src/src/contract.py:550-555
    // return (
    //     arc4.Address(address).bytes
    //     + arc4.UInt64(amount).bytes
    //     + arc4.UInt64(round).bytes
    //     + arc4.UInt64(index).bytes
    // )
    retsub


// contract.SlotMachine.kill() -> void:
kill:
    // src/src/contract.py:559-560
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    proto 0 0
    // src/src/contract.py:564
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:564
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // src/src/contract.py:565
    // assert self.updatable == UInt64(1), "not approved"
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:565
    // assert self.updatable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.updatable exists
    int 1
    ==
    assert // not approved
    // src/src/contract.py:566
    // assert self.deletable == UInt64(1), "not approved"
    int 0
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:566
    // assert self.deletable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.deletable exists
    int 1
    ==
    assert // not approved
    // src/src/contract.py:567
    // assert self.balance_locked == UInt64(0), "balance locked must be 0"
    int 0
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:567
    // assert self.balance_locked == UInt64(0), "balance locked must be 0"
    app_global_get_ex
    assert // check self.balance_locked exists
    !
    assert // balance locked must be 0
    // src/src/contract.py:568
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:568
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    app_global_get_ex
    assert // check self.upgrader exists
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:568
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    app_global_get_ex
    assert // check self.upgrader exists
    concat
    method "Closed(address,address)"
    swap
    concat
    log
    // src/src/contract.py:569
    // close_offline_on_delete(self.upgrader)
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:569
    // close_offline_on_delete(self.upgrader)
    app_global_get_ex
    assert // check self.upgrader exists
    callsub close_offline_on_delete
    retsub


// opensubmarine.utils.algorand.close_offline_on_delete(close_remainder_to: bytes) -> void:
close_offline_on_delete:
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:50-52
    // ##############################################
    // @subroutine
    // def close_offline_on_delete(close_remainder_to: Account) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:53
    // oca = Txn.on_completion
    txn OnCompletion
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:54
    // if oca == OnCompleteAction.DeleteApplication:
    int DeleteApplication
    ==
    assert
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:70
    // receiver=Global.creator_address,
    global CreatorAddress
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:73
    // amount=op.Global.min_balance,
    global MinBalance
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_begin
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:64-66
    // state_proof_key=Bytes.from_base64(
    //     "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
    // ),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
    itxn_field StateProofPK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:63
    // vote_key_dilution=UInt64(0),
    int 0
    itxn_field VoteKeyDilution
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:62
    // vote_last=UInt64(0),
    int 0
    itxn_field VoteLast
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:61
    // vote_first=UInt64(0),
    int 0
    itxn_field VoteFirst
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:58-60
    // selection_key=Bytes.from_base64(
    //     "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
    // ),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
    itxn_field SelectionPK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:57
    // vote_key=Bytes.from_base64("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
    itxn_field VotePK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:56
    // non_participation=True,
    int 1
    itxn_field Nonparticipation
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:55
    // keyreg_txn = itxn.KeyRegistration(
    int keyreg
    itxn_field TypeEnum
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:67
    // fee=0,
    int 0
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_next
    itxn_field Amount
    frame_dig -1
    itxn_field CloseRemainderTo
    itxn_field Receiver
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:69
    // pmt_txn = itxn.Payment(
    int pay
    itxn_field TypeEnum
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:72
    // fee=0,
    int 0
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_submit
    retsub


// contract.SlotMachineInterface.spin(bet_amount: bytes, index: bytes) -> bytes:
spin:
    // src/src/contract.py:300-301
    // @arc4.abimethod
    // def spin(self, bet_amount: arc4.UInt64, index: arc4.UInt64) -> Bytes56:
    proto 2 1
    // src/src/contract.py:313
    // return Bytes56.from_bytes(self._spin(bet_amount.native, index.native))
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    callsub _spin
    retsub


// contract.SlotMachine._spin(bet_amount: uint64, index: uint64) -> bytes:
_spin:
    // src/src/contract.py:592-594
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, index: UInt64) -> Bytes:
    proto 2 1
    // src/src/contract.py:606
    // assert bet_amount >= self.min_bet_amount, "bet amount too small"
    int 0
    // src/src/contract.py:381
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:606
    // assert bet_amount >= self.min_bet_amount, "bet amount too small"
    app_global_get_ex
    assert // check self.min_bet_amount exists
    frame_dig -2
    <=
    assert // bet amount too small
    // src/src/contract.py:607
    // assert bet_amount <= self.max_bet_amount, "bet amount too large"
    int 0
    // src/src/contract.py:382
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:607
    // assert bet_amount <= self.max_bet_amount, "bet amount too large"
    app_global_get_ex
    assert // check self.max_bet_amount exists
    frame_dig -2
    >=
    assert // bet amount too large
    // src/src/contract.py:608
    // payment = require_payment(Txn.sender)
    txn Sender
    callsub require_payment
    // src/src/contract.py:609
    // assert payment >= bet_amount, "payment insufficient"
    dup
    frame_dig -2
    >=
    assert // payment insufficient
    // src/src/contract.py:610
    // extra_payment = payment - bet_amount
    frame_dig -2
    -
    // src/src/contract.py:612
    // extra_payment >= BOX_COST_BET
    dup
    int 37700
    >=
    // src/src/contract.py:611-613
    // assert (
    //     extra_payment >= BOX_COST_BET
    // ), "extra payment must be greater than box cost"
    assert // extra payment must be greater than box cost
    // src/src/contract.py:615
    // extra_payment <= MAX_EXTRA_PAYMENT
    int 1000000
    <=
    // src/src/contract.py:614-616
    // assert (
    //     extra_payment <= MAX_EXTRA_PAYMENT
    // ), "extra payment must be less than max extra payment"
    assert // extra payment must be less than max extra payment
    // src/src/contract.py:617-618
    // # lock spin if balance total is less than min bank amount
    // assert self.balance_total >= self.min_bank_amount, "balance total must be greater than min bank amount"
    int 0
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:617-618
    // # lock spin if balance total is less than min bank amount
    // assert self.balance_total >= self.min_bank_amount, "balance total must be greater than min bank amount"
    app_global_get_ex
    assert // check self.balance_total exists
    int 0
    // src/src/contract.py:383
    // self.min_bank_amount = UInt64(MIN_BANK_AMOUNT)  # 350,000 VOI
    byte "min_bank_amount"
    // src/src/contract.py:617-618
    // # lock spin if balance total is less than min bank amount
    // assert self.balance_total >= self.min_bank_amount, "balance total must be greater than min bank amount"
    app_global_get_ex
    assert // check self.min_bank_amount exists
    >=
    assert // balance total must be greater than min bank amount
    // src/src/contract.py:619-621
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    int 0
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:619-621
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    app_global_get_ex
    assert // check self.balance_total exists
    frame_dig -2
    +
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:619-621
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    swap
    app_global_put
    // src/src/contract.py:622
    // self.balance_available += bet_amount  # Add bet amount to available first
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:622
    // self.balance_available += bet_amount  # Add bet amount to available first
    app_global_get_ex
    assert // check self.balance_available exists
    frame_dig -2
    +
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:622
    // self.balance_available += bet_amount  # Add bet amount to available first
    swap
    app_global_put
    // src/src/contract.py:623
    // max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    frame_dig -2
    int 100
    *
    // src/src/contract.py:624
    // self.balance_locked += max_possible_payout
    int 0
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:624
    // self.balance_locked += max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    +
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:624
    // self.balance_locked += max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:625-626
    // # prevent underflow, impossible because it would err with result would be negative but good to have
    // assert self.balance_available >= max_possible_payout, "balance available must be greater than max possible payout"
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:625-626
    // # prevent underflow, impossible because it would err with result would be negative but good to have
    // assert self.balance_available >= max_possible_payout, "balance available must be greater than max possible payout"
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    >=
    assert // balance available must be greater than max possible payout
    // src/src/contract.py:627
    // self.balance_available -= max_possible_payout
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:627
    // self.balance_available -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_available exists
    swap
    -
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:627
    // self.balance_available -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:628-629
    // # Create bet
    // round = Global.round
    global Round
    // src/src/contract.py:630
    // bet_key = self._get_bet_key(Txn.sender, bet_amount, round, index)
    txn Sender
    frame_dig -2
    dig 2
    frame_dig -1
    callsub _get_bet_key
    // src/src/contract.py:385-631
    //     self.bet = BoxMap(Bytes, Bet, key_prefix="")
    // 
    // # guard methods
    // 
    // @subroutine
    // def only_owner(self) -> None:
    //     """
    //     Only callable by contract owner
    //     """
    //     assert Txn.sender == self.owner, "only owner can call this function"
    // 
    // # upgradeable methods
    // 
    // @arc4.abimethod
    // def post_upgrade(self) -> None:
    //     """
    //     Called after upgrade
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     self.contract_version = UInt64()
    //     self.deployment_version = UInt64()
    // 
    // # owner methods
    // 
    // @arc4.abimethod
    // def set_min_bank_amount(self, min_bank_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bank amount
    //     """
    //     self.only_owner()
    //     assert min_bank_amount.native >= MIN_BANK_AMOUNT, "min bank amount must be greater than 350,000 VOI"
    //     self.min_bank_amount = min_bank_amount.native
    // 
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    //     """
    //     Set the payout model
    //     """
    //     self.only_owner()
    //     assert app_id.native > 0, "app id must be greater than 0"
    //     self.payout_model = app_id.native
    // 
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bet amount
    //     """
    //     self.only_owner()
    //     assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    //     assert (
    //         min_bet_amount.native <= self.max_bet_amount
    //     ), "min bet amount must be less than max bet amount"
    //     self.min_bet_amount = min_bet_amount.native
    // 
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the maximum bet amount
    //     """
    //     self.only_owner()
    //     assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    //     assert (
    //         max_bet_amount.native >= self.min_bet_amount
    //     ), "max bet amount must be greater than min bet amount"
    //     self.max_bet_amount = max_bet_amount.native
    // 
    // @arc4.abimethod
    // def burn_upgreadable_fuse(self) -> None:
    //     """
    //     Burn the upgradeable fuse
    //     """
    //     self.only_owner()
    //     self.updatable = False
    // 
    // @arc4.abimethod
    // def burn_stakeable_fuse(self) -> None:
    //     """
    //     Burn the stakeable fuse
    //     """
    //     self.only_owner()
    //     self.stakeable = False
    // 
    // @arc4.abimethod
    // def burn_deletable_fuse(self) -> None:
    //     """
    //     Burn the deletable fuse
    //     """
    //     self.only_owner()
    //     self.deletable = False
    // 
    // # block seed utils
    // 
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    //     return op.Block.blk_seed(round)[-32:]
    // 
    // # bankroll management
    // 
    // @arc4.abimethod
    // def deposit(self) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     payment = require_payment(Txn.sender)
    //     assert payment > 0, "payment must be greater than 0"
    //     self.balance_total += payment
    //     self.balance_available += payment
    // 
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    //     """
    //     Withdraw funds from the contract
    //     Only callable by contract owner
    // 
    //     Args:
    //         amount: The amount of funds to withdraw in atomic units
    //     """
    //     self.only_owner()
    //     assert amount.native > UInt64(0), "amount must be greater than 0"
    //     assert amount.native <= self.balance_available, "insufficient balance"
    //     itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    //     self.balance_available -= amount.native
    //     self.balance_total -= amount.native
    // 
    // # balance methods
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_available(self) -> arc4.UInt64:
    //     """
    //     Get the available balance
    //     """
    //     return arc4.UInt64(self.balance_available)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_locked(self) -> arc4.UInt64:
    //     """
    //     Get the locked balance
    //     """
    //     return arc4.UInt64(self.balance_locked)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_total(self) -> arc4.UInt64:
    //     """
    //     Get the total balance
    //     """
    //     return arc4.UInt64(self.balance_total)
    // 
    // # bet key utils
    // 
    // @arc4.abimethod(readonly=True)
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    //     return Bytes56.from_bytes(
    //         self._get_bet_key(address.native, amount.native, round.native, index.native)
    //     )
    // 
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    //     return (
    //         arc4.Address(address).bytes
    //         + arc4.UInt64(amount).bytes
    //         + arc4.UInt64(round).bytes
    //         + arc4.UInt64(index).bytes
    //     )
    // 
    // # terminal methods
    // 
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    //     """
    //     Kill the contract
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     assert self.updatable == UInt64(1), "not approved"
    //     assert self.deletable == UInt64(1), "not approved"
    //     assert self.balance_locked == UInt64(0), "balance locked must be 0"
    //     arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    //     close_offline_on_delete(self.upgrader)
    // 
    // # slot machine methods
    // 
    // # @arc4.abimethod
    // # def spin(
    // #     self,
    // #     bet_amount: arc4.UInt64,
    // #     index: arc4.UInt64,
    // # ) -> Bytes56:
    // #     """
    // #     Spin the slot machine. Outcome is determined by the seed
    // #     of future round.
    // 
    // #     Args:
    // #         bet (uint): The player's wager.
    // #         index (uint): Player's choice of index.
    // 
    // #     Returns:
    // #         r (uint): The round number of the spin.
    // #     """
    // #     return Bytes56.from_bytes(self._spin(bet_amount.native, index.native))
    // 
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, index: UInt64) -> Bytes:
    //     """
    //     Spin the slot machine. Outcome is determined by the seed
    //     of future round.
    // 
    //     Args:
    //         bet (uint): The player's wager.
    //         index (uint): Player's choice of index.
    // 
    //     Returns:
    //         r (uint): The round number of the spin.
    //     """
    //     assert bet_amount >= self.min_bet_amount, "bet amount too small"
    //     assert bet_amount <= self.max_bet_amount, "bet amount too large"
    //     payment = require_payment(Txn.sender)
    //     assert payment >= bet_amount, "payment insufficient"
    //     extra_payment = payment - bet_amount
    //     assert (
    //         extra_payment >= BOX_COST_BET
    //     ), "extra payment must be greater than box cost"
    //     assert (
    //         extra_payment <= MAX_EXTRA_PAYMENT
    //     ), "extra payment must be less than max extra payment"
    //     # lock spin if balance total is less than min bank amount
    //     assert self.balance_total >= self.min_bank_amount, "balance total must be greater than min bank amount"
    //     # Update balance tracking
    //     #   Add bet amount to total balance
    //     self.balance_total += bet_amount
    //     self.balance_available += bet_amount  # Add bet amount to available first
    //     max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    //     self.balance_locked += max_possible_payout
    //     # prevent underflow, impossible because it would err with result would be negative but good to have
    //     assert self.balance_available >= max_possible_payout, "balance available must be greater than max possible payout"
    //     self.balance_available -= max_possible_payout
    //     # Create bet
    //     round = Global.round
    //     bet_key = self._get_bet_key(Txn.sender, bet_amount, round, index)
    //     assert bet_key not in self.bet, "bet already exists"
    dup
    box_len
    bury 1
    !
    // src/src/contract.py:631
    // assert bet_key not in self.bet, "bet already exists"
    assert // bet already exists
    // src/src/contract.py:632
    // claim_round = round + ROUND_FUTURE_DELTA
    dig 1
    int 1
    +
    swap
    // src/src/contract.py:634
    // who=arc4.Address(Txn.sender),
    txn Sender
    cover 2
    // src/src/contract.py:635
    // amount=arc4.UInt64(bet_amount),
    frame_dig -2
    itob
    swap
    // src/src/contract.py:636
    // confirmed_round=arc4.UInt64(round),
    uncover 4
    itob
    cover 2
    // src/src/contract.py:637
    // index=arc4.UInt64(index),
    frame_dig -1
    itob
    cover 4
    // src/src/contract.py:638
    // claim_round=arc4.UInt64(claim_round),
    uncover 3
    itob
    cover 4
    // src/src/contract.py:633-639
    // self.bet[bet_key] = Bet(
    //     who=arc4.Address(Txn.sender),
    //     amount=arc4.UInt64(bet_amount),
    //     confirmed_round=arc4.UInt64(round),
    //     index=arc4.UInt64(index),
    //     claim_round=arc4.UInt64(claim_round),
    // )
    uncover 5
    dig 2
    concat
    dig 3
    concat
    dig 4
    concat
    dig 5
    concat
    dig 1
    swap
    box_put
    // src/src/contract.py:642
    // who=arc4.Address(Txn.sender),
    txn Sender
    // src/src/contract.py:641-647
    // BetPlaced(
    //     who=arc4.Address(Txn.sender),
    //     amount=arc4.UInt64(bet_amount),
    //     confirmed_round=arc4.UInt64(round),
    //     index=arc4.UInt64(index),
    //     claim_round=arc4.UInt64(claim_round),
    // )
    uncover 2
    concat
    uncover 2
    concat
    uncover 2
    concat
    uncover 2
    concat
    // src/src/contract.py:640-648
    // arc4.emit(
    //     BetPlaced(
    //         who=arc4.Address(Txn.sender),
    //         amount=arc4.UInt64(bet_amount),
    //         confirmed_round=arc4.UInt64(round),
    //         index=arc4.UInt64(index),
    //         claim_round=arc4.UInt64(claim_round),
    //     )
    // )
    method "BetPlaced(address,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:649
    // return bet_key
    retsub


// contract.SlotMachineInterface.claim(bet_key: bytes) -> bytes:
claim:
    // src/src/contract.py:332-333
    // @arc4.abimethod
    // def claim(self, bet_key: Bytes56) -> arc4.UInt64:
    proto 1 1
    // src/src/contract.py:343
    // return arc4.UInt64(self._claim(bet_key.bytes))
    frame_dig -1
    callsub _claim
    itob
    retsub


// contract.SlotMachine._claim(bet_key: bytes) -> uint64:
_claim:
    // src/src/contract.py:664-666
    // # override
    // @subroutine
    // def _claim(self, bet_key: Bytes) -> UInt64:
    proto 1 1
    int 0
    dup
    byte ""
    // src/src/contract.py:385-675
    //     self.bet = BoxMap(Bytes, Bet, key_prefix="")
    // 
    // # guard methods
    // 
    // @subroutine
    // def only_owner(self) -> None:
    //     """
    //     Only callable by contract owner
    //     """
    //     assert Txn.sender == self.owner, "only owner can call this function"
    // 
    // # upgradeable methods
    // 
    // @arc4.abimethod
    // def post_upgrade(self) -> None:
    //     """
    //     Called after upgrade
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     self.contract_version = UInt64()
    //     self.deployment_version = UInt64()
    // 
    // # owner methods
    // 
    // @arc4.abimethod
    // def set_min_bank_amount(self, min_bank_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bank amount
    //     """
    //     self.only_owner()
    //     assert min_bank_amount.native >= MIN_BANK_AMOUNT, "min bank amount must be greater than 350,000 VOI"
    //     self.min_bank_amount = min_bank_amount.native
    // 
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    //     """
    //     Set the payout model
    //     """
    //     self.only_owner()
    //     assert app_id.native > 0, "app id must be greater than 0"
    //     self.payout_model = app_id.native
    // 
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bet amount
    //     """
    //     self.only_owner()
    //     assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    //     assert (
    //         min_bet_amount.native <= self.max_bet_amount
    //     ), "min bet amount must be less than max bet amount"
    //     self.min_bet_amount = min_bet_amount.native
    // 
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the maximum bet amount
    //     """
    //     self.only_owner()
    //     assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    //     assert (
    //         max_bet_amount.native >= self.min_bet_amount
    //     ), "max bet amount must be greater than min bet amount"
    //     self.max_bet_amount = max_bet_amount.native
    // 
    // @arc4.abimethod
    // def burn_upgreadable_fuse(self) -> None:
    //     """
    //     Burn the upgradeable fuse
    //     """
    //     self.only_owner()
    //     self.updatable = False
    // 
    // @arc4.abimethod
    // def burn_stakeable_fuse(self) -> None:
    //     """
    //     Burn the stakeable fuse
    //     """
    //     self.only_owner()
    //     self.stakeable = False
    // 
    // @arc4.abimethod
    // def burn_deletable_fuse(self) -> None:
    //     """
    //     Burn the deletable fuse
    //     """
    //     self.only_owner()
    //     self.deletable = False
    // 
    // # block seed utils
    // 
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    //     return op.Block.blk_seed(round)[-32:]
    // 
    // # bankroll management
    // 
    // @arc4.abimethod
    // def deposit(self) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     payment = require_payment(Txn.sender)
    //     assert payment > 0, "payment must be greater than 0"
    //     self.balance_total += payment
    //     self.balance_available += payment
    // 
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    //     """
    //     Withdraw funds from the contract
    //     Only callable by contract owner
    // 
    //     Args:
    //         amount: The amount of funds to withdraw in atomic units
    //     """
    //     self.only_owner()
    //     assert amount.native > UInt64(0), "amount must be greater than 0"
    //     assert amount.native <= self.balance_available, "insufficient balance"
    //     itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    //     self.balance_available -= amount.native
    //     self.balance_total -= amount.native
    // 
    // # balance methods
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_available(self) -> arc4.UInt64:
    //     """
    //     Get the available balance
    //     """
    //     return arc4.UInt64(self.balance_available)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_locked(self) -> arc4.UInt64:
    //     """
    //     Get the locked balance
    //     """
    //     return arc4.UInt64(self.balance_locked)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_total(self) -> arc4.UInt64:
    //     """
    //     Get the total balance
    //     """
    //     return arc4.UInt64(self.balance_total)
    // 
    // # bet key utils
    // 
    // @arc4.abimethod(readonly=True)
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    //     return Bytes56.from_bytes(
    //         self._get_bet_key(address.native, amount.native, round.native, index.native)
    //     )
    // 
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    //     return (
    //         arc4.Address(address).bytes
    //         + arc4.UInt64(amount).bytes
    //         + arc4.UInt64(round).bytes
    //         + arc4.UInt64(index).bytes
    //     )
    // 
    // # terminal methods
    // 
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    //     """
    //     Kill the contract
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     assert self.updatable == UInt64(1), "not approved"
    //     assert self.deletable == UInt64(1), "not approved"
    //     assert self.balance_locked == UInt64(0), "balance locked must be 0"
    //     arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    //     close_offline_on_delete(self.upgrader)
    // 
    // # slot machine methods
    // 
    // # @arc4.abimethod
    // # def spin(
    // #     self,
    // #     bet_amount: arc4.UInt64,
    // #     index: arc4.UInt64,
    // # ) -> Bytes56:
    // #     """
    // #     Spin the slot machine. Outcome is determined by the seed
    // #     of future round.
    // 
    // #     Args:
    // #         bet (uint): The player's wager.
    // #         index (uint): Player's choice of index.
    // 
    // #     Returns:
    // #         r (uint): The round number of the spin.
    // #     """
    // #     return Bytes56.from_bytes(self._spin(bet_amount.native, index.native))
    // 
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, index: UInt64) -> Bytes:
    //     """
    //     Spin the slot machine. Outcome is determined by the seed
    //     of future round.
    // 
    //     Args:
    //         bet (uint): The player's wager.
    //         index (uint): Player's choice of index.
    // 
    //     Returns:
    //         r (uint): The round number of the spin.
    //     """
    //     assert bet_amount >= self.min_bet_amount, "bet amount too small"
    //     assert bet_amount <= self.max_bet_amount, "bet amount too large"
    //     payment = require_payment(Txn.sender)
    //     assert payment >= bet_amount, "payment insufficient"
    //     extra_payment = payment - bet_amount
    //     assert (
    //         extra_payment >= BOX_COST_BET
    //     ), "extra payment must be greater than box cost"
    //     assert (
    //         extra_payment <= MAX_EXTRA_PAYMENT
    //     ), "extra payment must be less than max extra payment"
    //     # lock spin if balance total is less than min bank amount
    //     assert self.balance_total >= self.min_bank_amount, "balance total must be greater than min bank amount"
    //     # Update balance tracking
    //     #   Add bet amount to total balance
    //     self.balance_total += bet_amount
    //     self.balance_available += bet_amount  # Add bet amount to available first
    //     max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    //     self.balance_locked += max_possible_payout
    //     # prevent underflow, impossible because it would err with result would be negative but good to have
    //     assert self.balance_available >= max_possible_payout, "balance available must be greater than max possible payout"
    //     self.balance_available -= max_possible_payout
    //     # Create bet
    //     round = Global.round
    //     bet_key = self._get_bet_key(Txn.sender, bet_amount, round, index)
    //     assert bet_key not in self.bet, "bet already exists"
    //     claim_round = round + ROUND_FUTURE_DELTA
    //     self.bet[bet_key] = Bet(
    //         who=arc4.Address(Txn.sender),
    //         amount=arc4.UInt64(bet_amount),
    //         confirmed_round=arc4.UInt64(round),
    //         index=arc4.UInt64(index),
    //         claim_round=arc4.UInt64(claim_round),
    //     )
    //     arc4.emit(
    //         BetPlaced(
    //             who=arc4.Address(Txn.sender),
    //             amount=arc4.UInt64(bet_amount),
    //             confirmed_round=arc4.UInt64(round),
    //             index=arc4.UInt64(index),
    //             claim_round=arc4.UInt64(claim_round),
    //         )
    //     )
    //     return bet_key
    // 
    // # @arc4.abimethod
    // # def claim(self, bet_key: Bytes56) -> arc4.UInt64:
    // #     """
    // #     Claim a bet
    // 
    // #     Args:
    // #         bet_key: The key of the bet to claim
    // 
    // #     Returns:
    // #         payout: The payout for the bet
    // #     """
    // #     return arc4.UInt64(self._claim(bet_key.bytes))
    // 
    // # override
    // @subroutine
    // def _claim(self, bet_key: Bytes) -> UInt64:
    //     """
    //     Claim a bet
    //     Args:
    //         bet_key: The key of the bet to claim
    // 
    //     Returns:
    //         payout: The payout for the bet
    //     """
    //     assert bet_key in self.bet, "bet not found"
    frame_dig -1
    box_len
    bury 1
    // src/src/contract.py:675
    // assert bet_key in self.bet, "bet not found"
    assert // bet not found
    // src/src/contract.py:676
    // bet = self.bet[bet_key].copy()
    frame_dig -1
    box_get
    swap
    dup
    uncover 2
    assert // check self.bet entry exists
    // src/src/contract.py:677-679
    // # if round is greater than claim_round + MAX_CLAIM_ROUND_DELTA, the bet is expired
    // # and we can return the box cost to the sender
    // if Global.round > bet.claim_round.native + MAX_CLAIM_ROUND_DELTA:
    global Round
    swap
    extract 56 8 // on error: Index access is out of bounds
    dup
    cover 2
    btoi
    dup
    cover 2
    int 1000
    +
    >
    bz _claim_else_body@3
    // src/src/contract.py:680
    // del self.bet[bet_key]
    frame_dig -1
    box_del
    pop
    // src/src/contract.py:681-683
    // # Update balance tracking
    // #   Release locked balance and adjust available balance
    // max_possible_payout = bet.amount.native * UInt64(MAX_PAYOUT_MULTIPLIER)
    frame_dig 3
    dup
    extract 32 8 // on error: Index access is out of bounds
    dup
    btoi
    int 100
    *
    // src/src/contract.py:684
    // self.balance_locked -= max_possible_payout
    int 0
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:684
    // self.balance_locked -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    -
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:684
    // self.balance_locked -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:685
    // self.balance_available += max_possible_payout
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:685
    // self.balance_available += max_possible_payout
    app_global_get_ex
    assert // check self.balance_available exists
    +
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:685
    // self.balance_available += max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:686
    // itxn.Payment(receiver=Txn.sender, amount=BOX_COST_BET).submit()
    itxn_begin
    txn Sender
    int 37700
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:689
    // who=bet.who,
    dig 1
    extract 0 32 // on error: Index access is out of bounds
    swap
    // src/src/contract.py:691
    // confirmed_round=bet.confirmed_round,
    dig 2
    extract 40 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:692
    // index=bet.index,
    uncover 3
    extract 48 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:688-695
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=arc4.UInt64(0),
    // )
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig 4
    concat
    // src/src/contract.py:694
    // payout=arc4.UInt64(0),
    byte 0x0000000000000000
    // src/src/contract.py:688-695
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=arc4.UInt64(0),
    // )
    concat
    // src/src/contract.py:687-696
    // arc4.emit(
    //     BetClaimed(
    //         who=bet.who,
    //         amount=bet.amount,
    //         confirmed_round=bet.confirmed_round,
    //         index=bet.index,
    //         claim_round=bet.claim_round,
    //         payout=arc4.UInt64(0),
    //     )
    // )
    method "BetClaimed(address,uint64,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:697
    // return UInt64(0)
    int 0
    frame_bury 0
    retsub

_claim_else_body@3:
    // src/src/contract.py:701-702
    // # calculate r from block seed and bet key
    // combined = self._get_block_seed(bet.claim_round.native) + bet_key
    frame_dig 5
    callsub _get_block_seed
    frame_dig -1
    concat
    // src/src/contract.py:703
    // hashed = op.sha256(combined)
    sha256
    // src/src/contract.py:706
    // arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    byte 0x3b9aca00
    b%
    // src/src/contract.py:705-707
    // arc4.UInt256(
    //     arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    // ).bytes[-8:]
    dup
    len
    int 32
    <=
    assert // overflow
    int 32
    bzero
    b|
    dup
    len
    int 8
    dig 1
    >=
    int 8
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    // src/src/contract.py:704-708
    // r = arc4.UInt64.from_bytes(
    //     arc4.UInt256(
    //         arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    //     ).bytes[-8:]
    // )
    swap
    // src/src/contract.py:705-707
    // arc4.UInt256(
    //     arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    // ).bytes[-8:]
    substring3
    // src/src/contract.py:709-719
    // #########################################################
    // # get payout internal if subclass of SlotMachinePayoutModel
    // # otherwise call model to get payout
    // #########################################################
    // # payout = ar4.ab self._calculate_bet_payout(bet.amount.native, r)
    // payout, txn = arc4.abi_call(
    //     SlotMachinePayoutModelInterface.get_payout,
    //     bet.amount,
    //     r,
    //     app_id=Application(self.payout_model),
    // )
    itxn_begin
    // src/src/contract.py:716
    // bet.amount,
    frame_dig 3
    extract 32 8 // on error: Index access is out of bounds
    dup
    frame_bury 1
    // src/src/contract.py:718
    // app_id=Application(self.payout_model),
    int 0
    // src/src/contract.py:384
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    // src/src/contract.py:718
    // app_id=Application(self.payout_model),
    app_global_get_ex
    assert // check self.payout_model exists
    itxn_field ApplicationID
    // src/src/contract.py:709-719
    // #########################################################
    // # get payout internal if subclass of SlotMachinePayoutModel
    // # otherwise call model to get payout
    // #########################################################
    // # payout = ar4.ab self._calculate_bet_payout(bet.amount.native, r)
    // payout, txn = arc4.abi_call(
    //     SlotMachinePayoutModelInterface.get_payout,
    //     bet.amount,
    //     r,
    //     app_id=Application(self.payout_model),
    // )
    method "get_payout(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    int appl
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dup
    cover 3
    frame_bury 0
    extract 0 4
    byte 0x151f7c75
    ==
    assert // ARC4 prefix is valid
    // src/src/contract.py:720-723
    // #########################################################
    // # Update balance tracking
    // #   Release locked balance and adjust available balance
    // max_possible_payout = bet.amount.native * UInt64(MAX_PAYOUT_MULTIPLIER)
    btoi
    int 100
    *
    // src/src/contract.py:724
    // self.balance_locked -= max_possible_payout
    int 0
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:724
    // self.balance_locked -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    -
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:724
    // self.balance_locked -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:725
    // self.balance_available += (
    int 0
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:725
    // self.balance_available += (
    app_global_get_ex
    assert // check self.balance_available exists
    // src/src/contract.py:726
    // max_possible_payout - payout.native
    dig 2
    btoi
    dup
    frame_bury 2
    uncover 2
    dig 1
    -
    // src/src/contract.py:725-727
    // self.balance_available += (
    //     max_possible_payout - payout.native
    // )  # Release locked funds minus payout
    uncover 2
    +
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:725-727
    // self.balance_available += (
    //     max_possible_payout - payout.native
    // )  # Release locked funds minus payout
    swap
    app_global_put
    // src/src/contract.py:728
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    int 0
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:728
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    app_global_get_ex
    assert // check self.balance_total exists
    swap
    -
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:728
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    swap
    app_global_put
    // src/src/contract.py:729
    // if payout > 0:
    byte 0x0000000000000000
    b>
    bz _claim_after_if_else@7
    // src/src/contract.py:730
    // itxn.Payment(receiver=bet.who.native, amount=payout.native).submit()
    itxn_begin
    frame_dig 3
    extract 0 32 // on error: Index access is out of bounds
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit

_claim_after_if_else@7:
    // src/src/contract.py:731
    // del self.bet[bet_key]
    frame_dig -1
    box_del
    pop
    // src/src/contract.py:732
    // itxn.Payment(receiver=Txn.sender, amount=BOX_COST_BET).submit()
    itxn_begin
    txn Sender
    int 37700
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:735
    // who=bet.who,
    frame_dig 3
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    // src/src/contract.py:737
    // confirmed_round=bet.confirmed_round,
    dup
    extract 40 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:738
    // index=bet.index,
    extract 48 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:734-741
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=payout,
    // )
    frame_dig 1
    concat
    swap
    concat
    swap
    concat
    frame_dig 4
    concat
    frame_dig 0
    concat
    // src/src/contract.py:733-742
    // arc4.emit(
    //     BetClaimed(
    //         who=bet.who,
    //         amount=bet.amount,
    //         confirmed_round=bet.confirmed_round,
    //         index=bet.index,
    //         claim_round=bet.claim_round,
    //         payout=payout,
    //     )
    // )
    method "BetClaimed(address,uint64,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:743
    // return payout.native
    frame_dig 2
    frame_bury 0
    retsub


// contract.SlotMachine._get_block_seed(round: uint64) -> bytes:
_get_block_seed:
    // src/src/contract.py:477-478
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    proto 1 1
    // src/src/contract.py:479
    // return op.Block.blk_seed(round)[-32:]
    frame_dig -1
    block BlkSeed
    dup
    len
    int 32
    dig 1
    >=
    int 32
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    swap
    substring3
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.set_version(contract_version: bytes, deployment_version: bytes) -> void:
set_version:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83-86
    // @arc4.abimethod
    // def set_version(
    //     self, contract_version: arc4.UInt64, deployment_version: arc4.UInt64
    // ) -> None:
    proto 2 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:87
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:87
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:88
    // arc4.emit(VersionUpdated(contract_version, deployment_version))
    frame_dig -2
    frame_dig -1
    concat
    method "VersionUpdated(uint64,uint64)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:89
    // self.contract_version = contract_version.native
    frame_dig -2
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:89
    // self.contract_version = contract_version.native
    swap
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:90
    // self.deployment_version = deployment_version.native
    frame_dig -1
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:90
    // self.deployment_version = deployment_version.native
    swap
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.approve_update(approval: bytes) -> void:
approve_update:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101-102
    // @arc4.abimethod
    // def approve_update(self, approval: arc4.Bool) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:103
    // assert Txn.sender == self.owner, "must be owner"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:103
    // assert Txn.sender == self.owner, "must be owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // must be owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:104
    // arc4.emit(UpdateApproved(arc4.Address(self.owner), approval))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:104
    // arc4.emit(UpdateApproved(arc4.Address(self.owner), approval))
    app_global_get_ex
    assert // check self.owner exists
    frame_dig -1
    concat
    method "UpdateApproved(address,bool)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:105
    // self.updatable = approval.native
    frame_dig -1
    int 0
    getbit
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:105
    // self.updatable = approval.native
    swap
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.grant_upgrader(upgrader: bytes) -> void:
grant_upgrader:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107-108
    // @arc4.abimethod
    // def grant_upgrader(self, upgrader: arc4.Address) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:109
    // assert Txn.sender == Global.creator_address, "must be creator"
    txn Sender
    global CreatorAddress
    ==
    assert // must be creator
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:110
    // arc4.emit(UpgraderGranted(arc4.Address(self.upgrader), upgrader))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:110
    // arc4.emit(UpgraderGranted(arc4.Address(self.upgrader), upgrader))
    app_global_get_ex
    assert // check self.upgrader exists
    frame_dig -1
    concat
    method "UpgraderGranted(address,address)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:111
    // self.upgrader = upgrader.native
    frame_dig -1
    app_global_put
    retsub


// opensubmarine.contracts.participation.Stakable.contract.Stakeable.set_delegate(delegate: bytes) -> void:
set_delegate:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:81-82
    // @arc4.abimethod
    // def set_delegate(self, delegate: arc4.Address) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:84
    // Txn.sender == self.owner or Txn.sender == Global.creator_address
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:84
    // Txn.sender == self.owner or Txn.sender == Global.creator_address
    app_global_get_ex
    assert // check self.owner exists
    ==
    bnz set_delegate_bool_true@2
    txn Sender
    global CreatorAddress
    ==
    bz set_delegate_bool_false@3

set_delegate_bool_true@2:
    int 1
    b set_delegate_bool_merge@4

set_delegate_bool_false@3:
    int 0

set_delegate_bool_merge@4:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:83-85
    // assert (
    //     Txn.sender == self.owner or Txn.sender == Global.creator_address
    // ), "must be owner or creator"
    assert // must be owner or creator
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:86
    // arc4.emit(DelegateUpdated(arc4.Address(self.delegate), delegate))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:86
    // arc4.emit(DelegateUpdated(arc4.Address(self.delegate), delegate))
    app_global_get_ex
    assert // check self.delegate exists
    frame_dig -1
    concat
    method "DelegateUpdated(address,address)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:87
    // self.delegate = delegate.native
    frame_dig -1
    app_global_put
    retsub


// opensubmarine.contracts.participation.Stakable.contract.Stakeable.participate(vote_k: bytes, sel_k: bytes, vote_fst: bytes, vote_lst: bytes, vote_kd: bytes, sp_key: bytes) -> void:
participate:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:89-98
    // @arc4.abimethod
    // def participate(
    //     self,
    //     vote_k: Bytes32,
    //     sel_k: Bytes32,
    //     vote_fst: arc4.UInt64,
    //     vote_lst: arc4.UInt64,
    //     vote_kd: arc4.UInt64,
    //     sp_key: Bytes64,
    // ) -> None:
    proto 6 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:101
    // Txn.sender == self.owner or Txn.sender == self.delegate
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:101
    // Txn.sender == self.owner or Txn.sender == self.delegate
    app_global_get_ex
    assert // check self.owner exists
    ==
    bnz participate_bool_true@2
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:101
    // Txn.sender == self.owner or Txn.sender == self.delegate
    app_global_get_ex
    assert // check self.delegate exists
    ==
    bz participate_bool_false@3

participate_bool_true@2:
    int 1
    b participate_bool_merge@4

participate_bool_false@3:
    int 0

participate_bool_merge@4:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:99-102
    // ###########################################
    // assert (
    //     Txn.sender == self.owner or Txn.sender == self.delegate
    // ), "must be owner or delegate"
    assert // must be owner or delegate
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:103-104
    // ###########################################
    // key_reg_fee = Global.min_txn_fee
    global MinTxnFee
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:105-106
    // # require payment of min fee to prevent draining
    // assert require_payment(Txn.sender) == key_reg_fee, "payment amout accurate"
    txn Sender
    callsub require_payment
    dig 1
    ==
    assert // payment amout accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:110
    // arc4.Address(Txn.sender),
    txn Sender
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:112
    // address=arc4.Address(Txn.sender),
    dup
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:111-119
    // PartKeyInfo(
    //     address=arc4.Address(Txn.sender),
    //     vote_key=vote_k,
    //     selection_key=sel_k,
    //     vote_first=vote_fst,
    //     vote_last=vote_lst,
    //     vote_key_dilution=vote_kd,
    //     state_proof_key=sp_key,
    // ),
    frame_dig -6
    concat
    frame_dig -5
    concat
    frame_dig -4
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    frame_dig -1
    concat
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:109-120
    // Participated(
    //     arc4.Address(Txn.sender),
    //     PartKeyInfo(
    //         address=arc4.Address(Txn.sender),
    //         vote_key=vote_k,
    //         selection_key=sel_k,
    //         vote_first=vote_fst,
    //         vote_last=vote_lst,
    //         vote_key_dilution=vote_kd,
    //         state_proof_key=sp_key,
    //     ),
    // )
    concat
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:107-121
    // ###########################################
    // arc4.emit(
    //     Participated(
    //         arc4.Address(Txn.sender),
    //         PartKeyInfo(
    //             address=arc4.Address(Txn.sender),
    //             vote_key=vote_k,
    //             selection_key=sel_k,
    //             vote_first=vote_fst,
    //             vote_last=vote_lst,
    //             vote_key_dilution=vote_kd,
    //             state_proof_key=sp_key,
    //         ),
    //     )
    // )
    method "Participated(address,(address,byte[32],byte[32],uint64,uint64,uint64,byte[64]))"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:122-130
    // itxn.KeyRegistration(
    //     vote_key=vote_k.bytes,
    //     selection_key=sel_k.bytes,
    //     vote_first=vote_fst.native,
    //     vote_last=vote_lst.native,
    //     vote_key_dilution=vote_kd.native,
    //     state_proof_key=sp_key.bytes,
    //     fee=key_reg_fee,
    // ).submit()
    itxn_begin
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:125
    // vote_first=vote_fst.native,
    frame_dig -4
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:126
    // vote_last=vote_lst.native,
    frame_dig -3
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:127
    // vote_key_dilution=vote_kd.native,
    frame_dig -2
    btoi
    frame_dig -1
    itxn_field StateProofPK
    itxn_field VoteKeyDilution
    itxn_field VoteLast
    itxn_field VoteFirst
    frame_dig -5
    itxn_field SelectionPK
    frame_dig -6
    itxn_field VotePK
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:122
    // itxn.KeyRegistration(
    int keyreg
    itxn_field TypeEnum
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:122-130
    // itxn.KeyRegistration(
    //     vote_key=vote_k.bytes,
    //     selection_key=sel_k.bytes,
    //     vote_first=vote_fst.native,
    //     vote_last=vote_lst.native,
    //     vote_key_dilution=vote_kd.native,
    //     state_proof_key=sp_key.bytes,
    //     fee=key_reg_fee,
    // ).submit()
    itxn_submit
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.on_update() -> void:
on_update:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92-93
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def on_update(self) -> None:
    proto 0 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:94-97
    // ##########################################
    // # WARNING: This app can be updated by the creator
    // ##########################################
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:94-97
    // ##########################################
    // # WARNING: This app can be updated by the creator
    // ##########################################
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:98
    // assert self.updatable == UInt64(1), "not approved"
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:98
    // assert self.updatable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.updatable exists
    int 1
    ==
    assert // not approved
    retsub


// contract.Deleteable.on_delete() -> void:
on_delete:
    // src/src/contract.py:58-59
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    // def on_delete(self) -> None:  # pragma: no cover
    proto 0 0
    // src/src/contract.py:60-63
    // ##########################################
    // # WARNING: This app can be deleted by the creator (Development)
    // ##########################################
    // assert Txn.sender == Global.creator_address, "must be creator"
    txn Sender
    global CreatorAddress
    ==
    assert // must be creator
    // src/src/contract.py:64
    // assert self.deletable == UInt64(1), "not approved"
    int 0
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:64
    // assert self.deletable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.deletable exists
    int 1
    ==
    assert // not approved
    retsub


// contract.SlotMachine.__init__() -> void:
__init__:
    // src/src/contract.py:364
    // def __init__(self) -> None:
    proto 0 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // src/src/contract.py:365-366
    // # ownable state
    // self.owner = Global.creator_address  # set owner to creator
    global CreatorAddress
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // src/src/contract.py:367-368
    // # stakeable state
    // self.delegate = Account()  # zero address
    global ZeroAddress
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:48
    // self.stakeable = bool(1)
    byte "stakeable"
    // src/src/contract.py:369
    // self.stakeable = bool(1)  # 1 (Default unlocked)
    int 1
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // src/src/contract.py:370-371
    // # upgradable state
    // self.contract_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // src/src/contract.py:372
    // self.deployment_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:373
    // self.updatable = bool(1)
    int 1
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:374
    // self.upgrader = Global.creator_address
    global CreatorAddress
    app_global_put
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:375-376
    // # deleteable state
    // self.deletable = bool(1)
    int 1
    app_global_put
    // src/src/contract.py:377-378
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    int 0
    app_global_put
    // src/src/contract.py:379
    // self.balance_available = UInt64()
    byte "balance_available"
    int 0
    app_global_put
    // src/src/contract.py:380
    // self.balance_locked = UInt64()
    byte "balance_locked"
    int 0
    app_global_put
    // src/src/contract.py:381
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    int 1000000
    app_global_put
    // src/src/contract.py:382
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    int 1000000000
    app_global_put
    // src/src/contract.py:383
    // self.min_bank_amount = UInt64(MIN_BANK_AMOUNT)  # 350,000 VOI
    byte "min_bank_amount"
    int 350000000000
    app_global_put
    // src/src/contract.py:384
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    int 0
    app_global_put
    retsub
