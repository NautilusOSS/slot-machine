#pragma version 10

contract.SlotMachine.approval_program:
    txn ApplicationID
    bnz main_entrypoint@2
    callsub __init__

main_entrypoint@2:
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txn NumAppArgs
    bz main_bare_routing@31
    method "post_update()void"
    method "set_min_bank_amount(uint64)void"
    method "set_payout_model(uint64)void"
    method "set_min_bet_amount(uint64)void"
    method "set_max_bet_amount(uint64)void"
    method "burn_upgreadable_fuse()void"
    method "burn_stakeable_fuse()void"
    method "burn_deletable_fuse()void"
    method "owner_deposit(uint64)void"
    method "get_owner()address"
    method "deposit()void"
    method "withdraw(uint64)void"
    method "get_balance_available()uint64"
    method "get_balance_locked()uint64"
    method "get_balance_total()uint64"
    method "get_bet_key(address,uint64,uint64,uint64)byte[56]"
    method "kill()void"
    method "spin(uint64,uint64,uint64)byte[56]"
    method "claim(byte[56])uint64"
    method "transfer(address)void"
    method "set_version(uint64,uint64)void"
    method "approve_update(bool)void"
    method "grant_upgrader(address)void"
    method "set_delegate(address)void"
    method "participate(byte[32],byte[32],uint64,uint64,uint64,byte[64])void"
    txna ApplicationArgs 0
    match main_post_update_route@4 main_set_min_bank_amount_route@5 main_set_payout_model_route@6 main_set_min_bet_amount_route@7 main_set_max_bet_amount_route@8 main_burn_upgreadable_fuse_route@9 main_burn_stakeable_fuse_route@10 main_burn_deletable_fuse_route@11 main_owner_deposit_route@12 main_get_owner_route@13 main_deposit_route@14 main_withdraw_route@15 main_get_balance_available_route@16 main_get_balance_locked_route@17 main_get_balance_total_route@18 main_get_bet_key_route@19 main_kill_route@20 main_spin_route@21 main_claim_route@22 main_transfer_route@23 main_set_version_route@24 main_approve_update_route@25 main_grant_upgrader_route@26 main_set_delegate_route@27 main_participate_route@28
    err // reject transaction

main_post_update_route@4:
    // src/src/contract.py:458
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub post_update
    int 1
    return

main_set_min_bank_amount_route@5:
    // src/src/contract.py:467
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:467
    // @arc4.abimethod
    callsub set_min_bank_amount
    int 1
    return

main_set_payout_model_route@6:
    // src/src/contract.py:478
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:478
    // @arc4.abimethod
    callsub set_payout_model
    int 1
    return

main_set_min_bet_amount_route@7:
    // src/src/contract.py:487
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:487
    // @arc4.abimethod
    callsub set_min_bet_amount
    int 1
    return

main_set_max_bet_amount_route@8:
    // src/src/contract.py:499
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:499
    // @arc4.abimethod
    callsub set_max_bet_amount
    int 1
    return

main_burn_upgreadable_fuse_route@9:
    // src/src/contract.py:511
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub burn_upgreadable_fuse
    int 1
    return

main_burn_stakeable_fuse_route@10:
    // src/src/contract.py:519
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub burn_stakeable_fuse
    int 1
    return

main_burn_deletable_fuse_route@11:
    // src/src/contract.py:527
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub burn_deletable_fuse
    int 1
    return

main_owner_deposit_route@12:
    // src/src/contract.py:535
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:535
    // @arc4.abimethod
    callsub owner_deposit
    int 1
    return

main_get_owner_route@13:
    // src/src/contract.py:544
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub get_owner
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_deposit_route@14:
    // src/src/contract.py:559
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub deposit
    int 1
    return

main_withdraw_route@15:
    // src/src/contract.py:569
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:569
    // @arc4.abimethod
    callsub withdraw
    int 1
    return

main_get_balance_available_route@16:
    // src/src/contract.py:587
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub get_balance_available
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_get_balance_locked_route@17:
    // src/src/contract.py:594
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub get_balance_locked
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_get_balance_total_route@18:
    // src/src/contract.py:601
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub get_balance_total
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_get_bet_key_route@19:
    // src/src/contract.py:645
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // src/src/contract.py:645
    // @arc4.abimethod(readonly=True)
    callsub get_bet_key
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_kill_route@20:
    // src/src/contract.py:670
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    txn OnCompletion
    int DeleteApplication
    ==
    assert // OnCompletion is DeleteApplication
    txn ApplicationID
    assert // is not creating
    callsub kill
    int 1
    return

main_spin_route@21:
    // src/src/contract.py:335
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // src/src/contract.py:335
    // @arc4.abimethod
    callsub spin
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_claim_route@22:
    // src/src/contract.py:371
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:371
    // @arc4.abimethod
    callsub claim
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_transfer_route@23:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:34
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:34
    // @arc4.abimethod
    callsub transfer
    int 1
    return

main_set_version_route@24:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83
    // @arc4.abimethod
    callsub set_version
    int 1
    return

main_approve_update_route@25:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101
    // @arc4.abimethod
    callsub approve_update
    int 1
    return

main_grant_upgrader_route@26:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107
    // @arc4.abimethod
    callsub grant_upgrader
    int 1
    return

main_set_delegate_route@27:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:81
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:81
    // @arc4.abimethod
    callsub set_delegate
    int 1
    return

main_participate_route@28:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:89
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:89
    // @arc4.abimethod
    callsub participate
    int 1
    return

main_bare_routing@31:
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txn OnCompletion
    switch main_create@32 main_reject_bare_on_completion@35 main_reject_bare_on_completion@35 main_reject_bare_on_completion@35 main_on_update@33 main_on_delete@34
    err // reject transaction

main_create@32:
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    txn ApplicationID
    !
    assert // is creating
    int 1
    return

main_on_update@33:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    txn ApplicationID
    assert // is not creating
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92-93
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def on_update(self) -> None:
    callsub on_update
    int 1
    return

main_on_delete@34:
    // src/src/contract.py:58
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:58-59
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    // def on_delete(self) -> None:  # pragma: no cover
    callsub on_delete
    int 1
    return

main_reject_bare_on_completion@35:
    // src/src/contract.py:419
    // class SlotMachine(SlotMachineInterface, Ownable, Upgradeable, Stakeable, Deleteable):
    err // reject transaction


// contract.SlotMachine.post_update() -> void:
post_update:
    // src/src/contract.py:458-459
    // @arc4.abimethod
    // def post_update(self) -> None:
    proto 0 0
    // src/src/contract.py:463
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:463
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    retsub


// contract.SlotMachine.set_min_bank_amount(min_bank_amount: bytes) -> void:
set_min_bank_amount:
    // src/src/contract.py:467-468
    // @arc4.abimethod
    // def set_min_bank_amount(self, min_bank_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:472
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:474
    // min_bank_amount.native >= MIN_BANK_AMOUNT
    frame_dig -1
    btoi
    dup
    int 350000000000
    >=
    // src/src/contract.py:473-475
    // assert (
    //     min_bank_amount.native >= MIN_BANK_AMOUNT
    // ), "min bank amount must be greater than 350,000 VOI"
    assert // min bank amount must be greater than 350,000 VOI
    // src/src/contract.py:443
    // self.min_bank_amount = UInt64(MIN_BANK_AMOUNT)  # 350,000 VOI
    byte "min_bank_amount"
    // src/src/contract.py:476
    // self.min_bank_amount = min_bank_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.only_owner() -> void:
only_owner:
    // src/src/contract.py:449-450
    // @subroutine
    // def only_owner(self) -> None:
    proto 0 0
    // src/src/contract.py:454
    // assert Txn.sender == self.owner, "only owner can call this function"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // src/src/contract.py:454
    // assert Txn.sender == self.owner, "only owner can call this function"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // only owner can call this function
    retsub


// contract.SlotMachine.set_payout_model(app_id: bytes) -> void:
set_payout_model:
    // src/src/contract.py:478-479
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:483
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:484
    // assert app_id.native > 0, "app id must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // app id must be greater than 0
    // src/src/contract.py:444
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    // src/src/contract.py:485
    // self.payout_model = app_id.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.set_min_bet_amount(min_bet_amount: bytes) -> void:
set_min_bet_amount:
    // src/src/contract.py:487-488
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:492
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:493
    // assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // min bet amount must be greater than 0
    // src/src/contract.py:495
    // min_bet_amount.native <= self.max_bet_amount
    int 0
    // src/src/contract.py:442
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:495
    // min_bet_amount.native <= self.max_bet_amount
    app_global_get_ex
    assert // check self.max_bet_amount exists
    dig 1
    >=
    // src/src/contract.py:494-496
    // assert (
    //     min_bet_amount.native <= self.max_bet_amount
    // ), "min bet amount must be less than max bet amount"
    assert // min bet amount must be less than max bet amount
    // src/src/contract.py:441
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:497
    // self.min_bet_amount = min_bet_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.set_max_bet_amount(max_bet_amount: bytes) -> void:
set_max_bet_amount:
    // src/src/contract.py:499-500
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:504
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:505
    // assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // max bet amount must be greater than 0
    // src/src/contract.py:507
    // max_bet_amount.native >= self.min_bet_amount
    int 0
    // src/src/contract.py:441
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:507
    // max_bet_amount.native >= self.min_bet_amount
    app_global_get_ex
    assert // check self.min_bet_amount exists
    dig 1
    <=
    // src/src/contract.py:506-508
    // assert (
    //     max_bet_amount.native >= self.min_bet_amount
    // ), "max bet amount must be greater than min bet amount"
    assert // max bet amount must be greater than min bet amount
    // src/src/contract.py:442
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:509
    // self.max_bet_amount = max_bet_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.burn_upgreadable_fuse() -> void:
burn_upgreadable_fuse:
    // src/src/contract.py:511-512
    // @arc4.abimethod
    // def burn_upgreadable_fuse(self) -> None:
    proto 0 0
    // src/src/contract.py:516
    // self.only_owner()
    callsub only_owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:517
    // self.updatable = False
    int 0
    app_global_put
    retsub


// contract.SlotMachine.burn_stakeable_fuse() -> void:
burn_stakeable_fuse:
    // src/src/contract.py:519-520
    // @arc4.abimethod
    // def burn_stakeable_fuse(self) -> None:
    proto 0 0
    // src/src/contract.py:524
    // self.only_owner()
    callsub only_owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:48
    // self.stakeable = bool(1)
    byte "stakeable"
    // src/src/contract.py:525
    // self.stakeable = False
    int 0
    app_global_put
    retsub


// contract.SlotMachine.burn_deletable_fuse() -> void:
burn_deletable_fuse:
    // src/src/contract.py:527-528
    // @arc4.abimethod
    // def burn_deletable_fuse(self) -> None:
    proto 0 0
    // src/src/contract.py:532
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:533
    // self.deletable = False
    int 0
    app_global_put
    retsub


// contract.SlotMachine.owner_deposit(amount: bytes) -> void:
owner_deposit:
    // src/src/contract.py:535-536
    // @arc4.abimethod
    // def owner_deposit(self, amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:540
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:541
    // self.balance_total += amount.native
    int 0
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:541
    // self.balance_total += amount.native
    app_global_get_ex
    assert // check self.balance_total exists
    frame_dig -1
    btoi
    dup
    cover 2
    +
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:541
    // self.balance_total += amount.native
    swap
    app_global_put
    // src/src/contract.py:542
    // self.balance_available += amount.native
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:542
    // self.balance_available += amount.native
    app_global_get_ex
    assert // check self.balance_available exists
    +
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:542
    // self.balance_available += amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.get_owner() -> bytes:
get_owner:
    // src/src/contract.py:544-545
    // @arc4.abimethod
    // def get_owner(self) -> arc4.Address:
    proto 0 1
    // src/src/contract.py:549
    // return arc4.Address(self.owner)
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // src/src/contract.py:549
    // return arc4.Address(self.owner)
    app_global_get_ex
    assert // check self.owner exists
    retsub


// contract.SlotMachine.deposit() -> void:
deposit:
    // src/src/contract.py:559-560
    // @arc4.abimethod
    // def deposit(self) -> None:
    proto 0 0
    // src/src/contract.py:564
    // payment = require_payment(Txn.sender)
    txn Sender
    callsub require_payment
    // src/src/contract.py:565
    // assert payment > 0, "payment must be greater than 0"
    dup
    assert // payment must be greater than 0
    // src/src/contract.py:566
    // self.balance_total += payment
    int 0
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:566
    // self.balance_total += payment
    app_global_get_ex
    assert // check self.balance_total exists
    dig 1
    +
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:566
    // self.balance_total += payment
    swap
    app_global_put
    // src/src/contract.py:567
    // self.balance_available += payment
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:567
    // self.balance_available += payment
    app_global_get_ex
    assert // check self.balance_available exists
    +
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:567
    // self.balance_available += payment
    swap
    app_global_put
    retsub


// opensubmarine.utils.algorand.require_payment(who: bytes) -> uint64:
require_payment:
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:15-23
    // ##############################################
    // # function: require_payment (internal)
    // # arguments: None
    // # purpose: check payment
    // # pre-conditions: None
    // # post-conditions: None
    // ##############################################
    // @subroutine
    // def require_payment(who: Account) -> UInt64:
    proto 1 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:24
    // ref_group_index = Txn.group_index
    txn GroupIndex
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:25
    // assert ref_group_index > 0, "group index greater than zero"
    dup
    assert // group index greater than zero
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:26
    // payment_group_index = ref_group_index - 1
    int 1
    -
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:28
    // gtxn.PaymentTransaction(payment_group_index).sender == who
    dup
    gtxns TypeEnum
    int pay
    ==
    assert // transaction type is pay
    dup
    gtxns Sender
    frame_dig -1
    ==
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:27-29
    // assert (
    //     gtxn.PaymentTransaction(payment_group_index).sender == who
    // ), "payment sender accurate"
    assert // payment sender accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:31
    // gtxn.PaymentTransaction(payment_group_index).receiver
    dup
    gtxns Receiver
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:32
    // == Global.current_application_address
    global CurrentApplicationAddress
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:31-32
    // gtxn.PaymentTransaction(payment_group_index).receiver
    // == Global.current_application_address
    ==
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:30-33
    // assert (
    //     gtxn.PaymentTransaction(payment_group_index).receiver
    //     == Global.current_application_address
    // ), "payment receiver accurate"
    assert // payment receiver accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:34
    // return gtxn.PaymentTransaction(payment_group_index).amount
    gtxns Amount
    retsub


// contract.SlotMachine.withdraw(amount: bytes) -> void:
withdraw:
    // src/src/contract.py:569-570
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:578
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:579
    // assert amount.native > UInt64(0), "amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // amount must be greater than 0
    // src/src/contract.py:580
    // assert amount.native <= self.balance_available, "insufficient balance"
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:580
    // assert amount.native <= self.balance_available, "insufficient balance"
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    >=
    assert // insufficient balance
    // src/src/contract.py:581
    // itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    itxn_begin
    txn Sender
    dig 1
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:582
    // self.balance_available -= amount.native
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:582
    // self.balance_available -= amount.native
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    -
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:582
    // self.balance_available -= amount.native
    swap
    app_global_put
    // src/src/contract.py:583
    // self.balance_total -= amount.native
    int 0
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:583
    // self.balance_total -= amount.native
    app_global_get_ex
    assert // check self.balance_total exists
    swap
    -
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:583
    // self.balance_total -= amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.get_balance_available() -> bytes:
get_balance_available:
    // src/src/contract.py:587-588
    // @arc4.abimethod(readonly=True)
    // def get_balance_available(self) -> arc4.UInt64:
    proto 0 1
    // src/src/contract.py:592
    // return arc4.UInt64(self.balance_available)
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:592
    // return arc4.UInt64(self.balance_available)
    app_global_get_ex
    assert // check self.balance_available exists
    itob
    retsub


// contract.SlotMachine.get_balance_locked() -> bytes:
get_balance_locked:
    // src/src/contract.py:594-595
    // @arc4.abimethod(readonly=True)
    // def get_balance_locked(self) -> arc4.UInt64:
    proto 0 1
    // src/src/contract.py:599
    // return arc4.UInt64(self.balance_locked)
    int 0
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:599
    // return arc4.UInt64(self.balance_locked)
    app_global_get_ex
    assert // check self.balance_locked exists
    itob
    retsub


// contract.SlotMachine.get_balance_total() -> bytes:
get_balance_total:
    // src/src/contract.py:601-602
    // @arc4.abimethod(readonly=True)
    // def get_balance_total(self) -> arc4.UInt64:
    proto 0 1
    // src/src/contract.py:606
    // return arc4.UInt64(self.balance_total)
    int 0
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:606
    // return arc4.UInt64(self.balance_total)
    app_global_get_ex
    assert // check self.balance_total exists
    itob
    retsub


// contract.SlotMachine.get_bet_key(address: bytes, amount: bytes, round: bytes, index: bytes) -> bytes:
get_bet_key:
    // src/src/contract.py:645-652
    // @arc4.abimethod(readonly=True)
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    proto 4 1
    // src/src/contract.py:654
    // self._get_bet_key(address.native, amount.native, round.native, index.native)
    frame_dig -3
    btoi
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    frame_dig -4
    cover 3
    callsub _get_bet_key
    // src/src/contract.py:653-655
    // return Bytes56.from_bytes(
    //     self._get_bet_key(address.native, amount.native, round.native, index.native)
    // )
    retsub


// contract.SlotMachine._get_bet_key(address: bytes, amount: uint64, round: uint64, index: uint64) -> bytes:
_get_bet_key:
    // src/src/contract.py:657-660
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    proto 4 1
    // src/src/contract.py:663
    // + arc4.UInt64(amount).bytes
    frame_dig -3
    itob
    // src/src/contract.py:662-663
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    frame_dig -4
    swap
    concat
    // src/src/contract.py:664
    // + arc4.UInt64(round).bytes
    frame_dig -2
    itob
    // src/src/contract.py:662-664
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    // + arc4.UInt64(round).bytes
    concat
    // src/src/contract.py:665
    // + arc4.UInt64(index).bytes
    frame_dig -1
    itob
    // src/src/contract.py:662-665
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    // + arc4.UInt64(round).bytes
    // + arc4.UInt64(index).bytes
    concat
    // src/src/contract.py:661-666
    // return (
    //     arc4.Address(address).bytes
    //     + arc4.UInt64(amount).bytes
    //     + arc4.UInt64(round).bytes
    //     + arc4.UInt64(index).bytes
    // )
    retsub


// contract.SlotMachine.kill() -> void:
kill:
    // src/src/contract.py:670-671
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    proto 0 0
    // src/src/contract.py:675
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:675
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // src/src/contract.py:676
    // assert self.updatable == UInt64(1), "not approved"
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:676
    // assert self.updatable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.updatable exists
    int 1
    ==
    assert // not approved
    // src/src/contract.py:677
    // assert self.deletable == UInt64(1), "not approved"
    int 0
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:677
    // assert self.deletable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.deletable exists
    int 1
    ==
    assert // not approved
    // src/src/contract.py:678
    // assert self.balance_locked == UInt64(0), "balance locked must be 0"
    int 0
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:678
    // assert self.balance_locked == UInt64(0), "balance locked must be 0"
    app_global_get_ex
    assert // check self.balance_locked exists
    !
    assert // balance locked must be 0
    // src/src/contract.py:679
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:679
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    app_global_get_ex
    assert // check self.upgrader exists
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:679
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    app_global_get_ex
    assert // check self.upgrader exists
    concat
    method "Closed(address,address)"
    swap
    concat
    log
    // src/src/contract.py:680
    // close_offline_on_delete(self.upgrader)
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:680
    // close_offline_on_delete(self.upgrader)
    app_global_get_ex
    assert // check self.upgrader exists
    callsub close_offline_on_delete
    retsub


// opensubmarine.utils.algorand.close_offline_on_delete(close_remainder_to: bytes) -> void:
close_offline_on_delete:
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:50-52
    // ##############################################
    // @subroutine
    // def close_offline_on_delete(close_remainder_to: Account) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:53
    // oca = Txn.on_completion
    txn OnCompletion
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:54
    // if oca == OnCompleteAction.DeleteApplication:
    int DeleteApplication
    ==
    assert
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:70
    // receiver=Global.creator_address,
    global CreatorAddress
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:73
    // amount=op.Global.min_balance,
    global MinBalance
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_begin
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:64-66
    // state_proof_key=Bytes.from_base64(
    //     "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
    // ),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
    itxn_field StateProofPK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:63
    // vote_key_dilution=UInt64(0),
    int 0
    itxn_field VoteKeyDilution
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:62
    // vote_last=UInt64(0),
    int 0
    itxn_field VoteLast
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:61
    // vote_first=UInt64(0),
    int 0
    itxn_field VoteFirst
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:58-60
    // selection_key=Bytes.from_base64(
    //     "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
    // ),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
    itxn_field SelectionPK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:57
    // vote_key=Bytes.from_base64("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
    itxn_field VotePK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:56
    // non_participation=True,
    int 1
    itxn_field Nonparticipation
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:55
    // keyreg_txn = itxn.KeyRegistration(
    int keyreg
    itxn_field TypeEnum
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:67
    // fee=0,
    int 0
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_next
    itxn_field Amount
    frame_dig -1
    itxn_field CloseRemainderTo
    itxn_field Receiver
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:69
    // pmt_txn = itxn.Payment(
    int pay
    itxn_field TypeEnum
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:72
    // fee=0,
    int 0
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_submit
    retsub


// contract.SlotMachineInterface.spin(bet_amount: bytes, provider_id: bytes, index: bytes) -> bytes:
spin:
    // src/src/contract.py:335-338
    // @arc4.abimethod
    // def spin(
    //     self, bet_amount: arc4.UInt64, provider_id: arc4.UInt64, index: arc4.UInt64
    // ) -> Bytes56:
    proto 3 1
    // src/src/contract.py:351
    // self._spin(bet_amount.native, provider_id.native, index.native)
    frame_dig -3
    btoi
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    callsub _spin
    // src/src/contract.py:350-352
    // return Bytes56.from_bytes(
    //     self._spin(bet_amount.native, provider_id.native, index.native)
    // )
    retsub


// contract.SlotMachine._spin(bet_amount: uint64, provider_id: uint64, index: uint64) -> bytes:
_spin:
    // src/src/contract.py:682-685
    // # slot machine methods
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, provider_id: UInt64, index: UInt64) -> Bytes:
    proto 3 1
    // src/src/contract.py:697
    // assert bet_amount >= self.min_bet_amount, "bet amount too small"
    int 0
    // src/src/contract.py:441
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:697
    // assert bet_amount >= self.min_bet_amount, "bet amount too small"
    app_global_get_ex
    assert // check self.min_bet_amount exists
    frame_dig -3
    <=
    assert // bet amount too small
    // src/src/contract.py:698
    // assert bet_amount <= self.max_bet_amount, "bet amount too large"
    int 0
    // src/src/contract.py:442
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:698
    // assert bet_amount <= self.max_bet_amount, "bet amount too large"
    app_global_get_ex
    assert // check self.max_bet_amount exists
    frame_dig -3
    >=
    assert // bet amount too large
    // src/src/contract.py:699
    // payment = require_payment(Txn.sender)
    txn Sender
    callsub require_payment
    // src/src/contract.py:700
    // assert payment >= bet_amount, "payment insufficient"
    dup
    frame_dig -3
    >=
    assert // payment insufficient
    // src/src/contract.py:701
    // extra_payment = payment - bet_amount
    frame_dig -3
    -
    // src/src/contract.py:703
    // extra_payment >= BOX_COST_BET
    dup
    int 37700
    >=
    // src/src/contract.py:702-704
    // assert (
    //     extra_payment >= BOX_COST_BET
    // ), "extra payment must be greater than box cost"
    assert // extra payment must be greater than box cost
    // src/src/contract.py:706
    // extra_payment <= MAX_EXTRA_PAYMENT
    int 1000000
    <=
    // src/src/contract.py:705-707
    // assert (
    //     extra_payment <= MAX_EXTRA_PAYMENT
    // ), "extra payment must be less than max extra payment"
    assert // extra payment must be less than max extra payment
    // src/src/contract.py:710
    // self.balance_total >= self.min_bank_amount
    int 0
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:710
    // self.balance_total >= self.min_bank_amount
    app_global_get_ex
    assert // check self.balance_total exists
    int 0
    // src/src/contract.py:443
    // self.min_bank_amount = UInt64(MIN_BANK_AMOUNT)  # 350,000 VOI
    byte "min_bank_amount"
    // src/src/contract.py:710
    // self.balance_total >= self.min_bank_amount
    app_global_get_ex
    assert // check self.min_bank_amount exists
    >=
    // src/src/contract.py:708-711
    // # lock spin if balance total is less than min bank amount
    // assert (
    //     self.balance_total >= self.min_bank_amount
    // ), "balance total must be greater than min bank amount"
    assert // balance total must be greater than min bank amount
    // src/src/contract.py:712-714
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    int 0
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:712-714
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    app_global_get_ex
    assert // check self.balance_total exists
    frame_dig -3
    +
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:712-714
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    swap
    app_global_put
    // src/src/contract.py:715
    // self.balance_available += bet_amount  # Add bet amount to available first
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:715
    // self.balance_available += bet_amount  # Add bet amount to available first
    app_global_get_ex
    assert // check self.balance_available exists
    frame_dig -3
    +
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:715
    // self.balance_available += bet_amount  # Add bet amount to available first
    swap
    app_global_put
    // src/src/contract.py:716
    // max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    frame_dig -3
    int 100
    *
    // src/src/contract.py:717
    // self.balance_locked += max_possible_payout
    int 0
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:717
    // self.balance_locked += max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    +
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:717
    // self.balance_locked += max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:720
    // self.balance_available >= max_possible_payout
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:720
    // self.balance_available >= max_possible_payout
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    >=
    // src/src/contract.py:718-721
    // # prevent underflow, impossible because it would err with result would be negative but good to have
    // assert (
    //     self.balance_available >= max_possible_payout
    // ), "balance available must be greater than max possible payout"
    assert // balance available must be greater than max possible payout
    // src/src/contract.py:722
    // self.balance_available -= max_possible_payout
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:722
    // self.balance_available -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_available exists
    swap
    -
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:722
    // self.balance_available -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:723-724
    // # Create bet
    // confirmed_round = Global.round
    global Round
    // src/src/contract.py:725
    // bet_key = self._get_bet_key(Txn.sender, bet_amount, provider_id, index)
    txn Sender
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub _get_bet_key
    // src/src/contract.py:445-726
    //     self.bet = BoxMap(Bytes, Bet, key_prefix="")
    // 
    // # guard methods
    // 
    // @subroutine
    // def only_owner(self) -> None:
    //     """
    //     Only callable by contract owner
    //     """
    //     assert Txn.sender == self.owner, "only owner can call this function"
    // 
    // # upgradeable methods
    // 
    // @arc4.abimethod
    // def post_update(self) -> None:
    //     """
    //     Called after upgrade
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    // 
    // # owner methods
    // 
    // @arc4.abimethod
    // def set_min_bank_amount(self, min_bank_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bank amount
    //     """
    //     self.only_owner()
    //     assert (
    //         min_bank_amount.native >= MIN_BANK_AMOUNT
    //     ), "min bank amount must be greater than 350,000 VOI"
    //     self.min_bank_amount = min_bank_amount.native
    // 
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    //     """
    //     Set the payout model
    //     """
    //     self.only_owner()
    //     assert app_id.native > 0, "app id must be greater than 0"
    //     self.payout_model = app_id.native
    // 
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bet amount
    //     """
    //     self.only_owner()
    //     assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    //     assert (
    //         min_bet_amount.native <= self.max_bet_amount
    //     ), "min bet amount must be less than max bet amount"
    //     self.min_bet_amount = min_bet_amount.native
    // 
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the maximum bet amount
    //     """
    //     self.only_owner()
    //     assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    //     assert (
    //         max_bet_amount.native >= self.min_bet_amount
    //     ), "max bet amount must be greater than min bet amount"
    //     self.max_bet_amount = max_bet_amount.native
    // 
    // @arc4.abimethod
    // def burn_upgreadable_fuse(self) -> None:
    //     """
    //     Burn the upgradeable fuse
    //     """
    //     self.only_owner()
    //     self.updatable = False
    // 
    // @arc4.abimethod
    // def burn_stakeable_fuse(self) -> None:
    //     """
    //     Burn the stakeable fuse
    //     """
    //     self.only_owner()
    //     self.stakeable = False
    // 
    // @arc4.abimethod
    // def burn_deletable_fuse(self) -> None:
    //     """
    //     Burn the deletable fuse
    //     """
    //     self.only_owner()
    //     self.deletable = False
    // 
    // @arc4.abimethod
    // def owner_deposit(self, amount: arc4.UInt64) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     self.only_owner()
    //     self.balance_total += amount.native
    //     self.balance_available += amount.native
    // 
    // @arc4.abimethod
    // def get_owner(self) -> arc4.Address:
    //     """
    //     Get the owner of the contract
    //     """
    //     return arc4.Address(self.owner)
    // 
    // # block seed utils
    // 
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    //     return op.Block.blk_seed(round)[-32:]
    // 
    // # bankroll management
    // 
    // @arc4.abimethod
    // def deposit(self) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     payment = require_payment(Txn.sender)
    //     assert payment > 0, "payment must be greater than 0"
    //     self.balance_total += payment
    //     self.balance_available += payment
    // 
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    //     """
    //     Withdraw funds from the contract
    //     Only callable by contract owner
    // 
    //     Args:
    //         amount: The amount of funds to withdraw in atomic units
    //     """
    //     self.only_owner()
    //     assert amount.native > UInt64(0), "amount must be greater than 0"
    //     assert amount.native <= self.balance_available, "insufficient balance"
    //     itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    //     self.balance_available -= amount.native
    //     self.balance_total -= amount.native
    // 
    // # balance methods
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_available(self) -> arc4.UInt64:
    //     """
    //     Get the available balance
    //     """
    //     return arc4.UInt64(self.balance_available)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_locked(self) -> arc4.UInt64:
    //     """
    //     Get the locked balance
    //     """
    //     return arc4.UInt64(self.balance_locked)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_total(self) -> arc4.UInt64:
    //     """
    //     Get the total balance
    //     """
    //     return arc4.UInt64(self.balance_total)
    // 
    // # embedded payout model
    // 
    // @subroutine
    // def _calculate_bet_payout(self, bet_amount: UInt64, r: UInt64) -> UInt64:
    //     """
    //     Simulate a single slot payout using weighted random thresholds.
    //     Random number r is in [0, 1_000_000_000). Uses if/then/else-style logic
    //     directly subtracting each probability from r until a match is found.
    //     """
    //     payout_model = PayoutModel(
    //         multipliers=arc4.StaticArray[arc4.UInt64, typing.Literal[6]](
    //             arc4.UInt64(100),
    //             arc4.UInt64(50),
    //             arc4.UInt64(20),
    //             arc4.UInt64(10),
    //             arc4.UInt64(5),
    //             arc4.UInt64(2),
    //         ),
    //         probabilities=arc4.StaticArray[arc4.UInt64, typing.Literal[6]](
    //             arc4.UInt64(82758),
    //             arc4.UInt64(1655172),
    //             arc4.UInt64(8275862),
    //             arc4.UInt64(16551724),
    //             arc4.UInt64(41379310),
    //             arc4.UInt64(165517241),
    //         ),
    //     )
    //     for index in urange(6):
    //         prob = payout_model.probabilities[index].native
    //         if r < prob:
    //             return bet_amount * payout_model.multipliers[index].native
    //         r -= prob
    // 
    //     return UInt64(0)
    // 
    // # bet key utils
    // 
    // @arc4.abimethod(readonly=True)
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    //     return Bytes56.from_bytes(
    //         self._get_bet_key(address.native, amount.native, round.native, index.native)
    //     )
    // 
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    //     return (
    //         arc4.Address(address).bytes
    //         + arc4.UInt64(amount).bytes
    //         + arc4.UInt64(round).bytes
    //         + arc4.UInt64(index).bytes
    //     )
    // 
    // # terminal methods
    // 
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    //     """
    //     Kill the contract
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     assert self.updatable == UInt64(1), "not approved"
    //     assert self.deletable == UInt64(1), "not approved"
    //     assert self.balance_locked == UInt64(0), "balance locked must be 0"
    //     arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    //     close_offline_on_delete(self.upgrader)
    // 
    // # slot machine methods
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, provider_id: UInt64, index: UInt64) -> Bytes:
    //     """
    //     Spin the slot machine. Outcome is determined by the seed
    //     of future round.
    // 
    //     Args:
    //         bet (uint): The player's wager.
    //         index (uint): Player's choice of index.
    // 
    //     Returns:
    //         r (uint): The round number of the spin.
    //     """
    //     assert bet_amount >= self.min_bet_amount, "bet amount too small"
    //     assert bet_amount <= self.max_bet_amount, "bet amount too large"
    //     payment = require_payment(Txn.sender)
    //     assert payment >= bet_amount, "payment insufficient"
    //     extra_payment = payment - bet_amount
    //     assert (
    //         extra_payment >= BOX_COST_BET
    //     ), "extra payment must be greater than box cost"
    //     assert (
    //         extra_payment <= MAX_EXTRA_PAYMENT
    //     ), "extra payment must be less than max extra payment"
    //     # lock spin if balance total is less than min bank amount
    //     assert (
    //         self.balance_total >= self.min_bank_amount
    //     ), "balance total must be greater than min bank amount"
    //     # Update balance tracking
    //     #   Add bet amount to total balance
    //     self.balance_total += bet_amount
    //     self.balance_available += bet_amount  # Add bet amount to available first
    //     max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    //     self.balance_locked += max_possible_payout
    //     # prevent underflow, impossible because it would err with result would be negative but good to have
    //     assert (
    //         self.balance_available >= max_possible_payout
    //     ), "balance available must be greater than max possible payout"
    //     self.balance_available -= max_possible_payout
    //     # Create bet
    //     confirmed_round = Global.round
    //     bet_key = self._get_bet_key(Txn.sender, bet_amount, provider_id, index)
    //     assert bet_key not in self.bet, "bet already exists"
    dup
    box_len
    bury 1
    !
    // src/src/contract.py:726
    // assert bet_key not in self.bet, "bet already exists"
    assert // bet already exists
    // src/src/contract.py:727
    // claim_round = confirmed_round + ROUND_FUTURE_DELTA
    dig 1
    int 1
    +
    swap
    // src/src/contract.py:729
    // who=arc4.Address(Txn.sender),
    txn Sender
    cover 2
    // src/src/contract.py:730
    // amount=arc4.UInt64(bet_amount),
    frame_dig -3
    itob
    swap
    // src/src/contract.py:731
    // confirmed_round=arc4.UInt64(confirmed_round),
    uncover 4
    itob
    cover 2
    // src/src/contract.py:732
    // index=arc4.UInt64(index),
    frame_dig -1
    itob
    cover 4
    // src/src/contract.py:733
    // claim_round=arc4.UInt64(claim_round),
    uncover 3
    itob
    cover 4
    // src/src/contract.py:728-734
    // self.bet[bet_key] = Bet(
    //     who=arc4.Address(Txn.sender),
    //     amount=arc4.UInt64(bet_amount),
    //     confirmed_round=arc4.UInt64(confirmed_round),
    //     index=arc4.UInt64(index),
    //     claim_round=arc4.UInt64(claim_round),
    // )
    uncover 5
    dig 2
    concat
    dig 3
    concat
    dig 4
    concat
    dig 5
    concat
    dig 1
    swap
    box_put
    // src/src/contract.py:737
    // who=arc4.Address(Txn.sender),
    txn Sender
    // src/src/contract.py:736-742
    // BetPlaced(
    //     who=arc4.Address(Txn.sender),
    //     amount=arc4.UInt64(bet_amount),
    //     confirmed_round=arc4.UInt64(confirmed_round),
    //     index=arc4.UInt64(index),
    //     claim_round=arc4.UInt64(claim_round),
    // )
    uncover 2
    concat
    uncover 2
    concat
    uncover 2
    concat
    uncover 2
    concat
    // src/src/contract.py:735-743
    // arc4.emit(
    //     BetPlaced(
    //         who=arc4.Address(Txn.sender),
    //         amount=arc4.UInt64(bet_amount),
    //         confirmed_round=arc4.UInt64(confirmed_round),
    //         index=arc4.UInt64(index),
    //         claim_round=arc4.UInt64(claim_round),
    //     )
    // )
    method "BetPlaced(address,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:744
    // return bet_key
    retsub


// contract.SlotMachineInterface.claim(bet_key: bytes) -> bytes:
claim:
    // src/src/contract.py:371-372
    // @arc4.abimethod
    // def claim(self, bet_key: Bytes56) -> arc4.UInt64:
    proto 1 1
    // src/src/contract.py:382
    // return arc4.UInt64(self._claim(bet_key.bytes))
    frame_dig -1
    callsub _claim
    itob
    retsub


// contract.SlotMachine._claim(bet_key: bytes) -> uint64:
_claim:
    // src/src/contract.py:746-748
    // # override
    // @subroutine
    // def _claim(self, bet_key: Bytes) -> UInt64:
    proto 1 1
    int 0
    dup
    byte ""
    // src/src/contract.py:445-757
    //     self.bet = BoxMap(Bytes, Bet, key_prefix="")
    // 
    // # guard methods
    // 
    // @subroutine
    // def only_owner(self) -> None:
    //     """
    //     Only callable by contract owner
    //     """
    //     assert Txn.sender == self.owner, "only owner can call this function"
    // 
    // # upgradeable methods
    // 
    // @arc4.abimethod
    // def post_update(self) -> None:
    //     """
    //     Called after upgrade
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    // 
    // # owner methods
    // 
    // @arc4.abimethod
    // def set_min_bank_amount(self, min_bank_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bank amount
    //     """
    //     self.only_owner()
    //     assert (
    //         min_bank_amount.native >= MIN_BANK_AMOUNT
    //     ), "min bank amount must be greater than 350,000 VOI"
    //     self.min_bank_amount = min_bank_amount.native
    // 
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    //     """
    //     Set the payout model
    //     """
    //     self.only_owner()
    //     assert app_id.native > 0, "app id must be greater than 0"
    //     self.payout_model = app_id.native
    // 
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bet amount
    //     """
    //     self.only_owner()
    //     assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    //     assert (
    //         min_bet_amount.native <= self.max_bet_amount
    //     ), "min bet amount must be less than max bet amount"
    //     self.min_bet_amount = min_bet_amount.native
    // 
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the maximum bet amount
    //     """
    //     self.only_owner()
    //     assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    //     assert (
    //         max_bet_amount.native >= self.min_bet_amount
    //     ), "max bet amount must be greater than min bet amount"
    //     self.max_bet_amount = max_bet_amount.native
    // 
    // @arc4.abimethod
    // def burn_upgreadable_fuse(self) -> None:
    //     """
    //     Burn the upgradeable fuse
    //     """
    //     self.only_owner()
    //     self.updatable = False
    // 
    // @arc4.abimethod
    // def burn_stakeable_fuse(self) -> None:
    //     """
    //     Burn the stakeable fuse
    //     """
    //     self.only_owner()
    //     self.stakeable = False
    // 
    // @arc4.abimethod
    // def burn_deletable_fuse(self) -> None:
    //     """
    //     Burn the deletable fuse
    //     """
    //     self.only_owner()
    //     self.deletable = False
    // 
    // @arc4.abimethod
    // def owner_deposit(self, amount: arc4.UInt64) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     self.only_owner()
    //     self.balance_total += amount.native
    //     self.balance_available += amount.native
    // 
    // @arc4.abimethod
    // def get_owner(self) -> arc4.Address:
    //     """
    //     Get the owner of the contract
    //     """
    //     return arc4.Address(self.owner)
    // 
    // # block seed utils
    // 
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    //     return op.Block.blk_seed(round)[-32:]
    // 
    // # bankroll management
    // 
    // @arc4.abimethod
    // def deposit(self) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     payment = require_payment(Txn.sender)
    //     assert payment > 0, "payment must be greater than 0"
    //     self.balance_total += payment
    //     self.balance_available += payment
    // 
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    //     """
    //     Withdraw funds from the contract
    //     Only callable by contract owner
    // 
    //     Args:
    //         amount: The amount of funds to withdraw in atomic units
    //     """
    //     self.only_owner()
    //     assert amount.native > UInt64(0), "amount must be greater than 0"
    //     assert amount.native <= self.balance_available, "insufficient balance"
    //     itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    //     self.balance_available -= amount.native
    //     self.balance_total -= amount.native
    // 
    // # balance methods
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_available(self) -> arc4.UInt64:
    //     """
    //     Get the available balance
    //     """
    //     return arc4.UInt64(self.balance_available)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_locked(self) -> arc4.UInt64:
    //     """
    //     Get the locked balance
    //     """
    //     return arc4.UInt64(self.balance_locked)
    // 
    // @arc4.abimethod(readonly=True)
    // def get_balance_total(self) -> arc4.UInt64:
    //     """
    //     Get the total balance
    //     """
    //     return arc4.UInt64(self.balance_total)
    // 
    // # embedded payout model
    // 
    // @subroutine
    // def _calculate_bet_payout(self, bet_amount: UInt64, r: UInt64) -> UInt64:
    //     """
    //     Simulate a single slot payout using weighted random thresholds.
    //     Random number r is in [0, 1_000_000_000). Uses if/then/else-style logic
    //     directly subtracting each probability from r until a match is found.
    //     """
    //     payout_model = PayoutModel(
    //         multipliers=arc4.StaticArray[arc4.UInt64, typing.Literal[6]](
    //             arc4.UInt64(100),
    //             arc4.UInt64(50),
    //             arc4.UInt64(20),
    //             arc4.UInt64(10),
    //             arc4.UInt64(5),
    //             arc4.UInt64(2),
    //         ),
    //         probabilities=arc4.StaticArray[arc4.UInt64, typing.Literal[6]](
    //             arc4.UInt64(82758),
    //             arc4.UInt64(1655172),
    //             arc4.UInt64(8275862),
    //             arc4.UInt64(16551724),
    //             arc4.UInt64(41379310),
    //             arc4.UInt64(165517241),
    //         ),
    //     )
    //     for index in urange(6):
    //         prob = payout_model.probabilities[index].native
    //         if r < prob:
    //             return bet_amount * payout_model.multipliers[index].native
    //         r -= prob
    // 
    //     return UInt64(0)
    // 
    // # bet key utils
    // 
    // @arc4.abimethod(readonly=True)
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    //     return Bytes56.from_bytes(
    //         self._get_bet_key(address.native, amount.native, round.native, index.native)
    //     )
    // 
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    //     return (
    //         arc4.Address(address).bytes
    //         + arc4.UInt64(amount).bytes
    //         + arc4.UInt64(round).bytes
    //         + arc4.UInt64(index).bytes
    //     )
    // 
    // # terminal methods
    // 
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    //     """
    //     Kill the contract
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     assert self.updatable == UInt64(1), "not approved"
    //     assert self.deletable == UInt64(1), "not approved"
    //     assert self.balance_locked == UInt64(0), "balance locked must be 0"
    //     arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    //     close_offline_on_delete(self.upgrader)
    // 
    // # slot machine methods
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, provider_id: UInt64, index: UInt64) -> Bytes:
    //     """
    //     Spin the slot machine. Outcome is determined by the seed
    //     of future round.
    // 
    //     Args:
    //         bet (uint): The player's wager.
    //         index (uint): Player's choice of index.
    // 
    //     Returns:
    //         r (uint): The round number of the spin.
    //     """
    //     assert bet_amount >= self.min_bet_amount, "bet amount too small"
    //     assert bet_amount <= self.max_bet_amount, "bet amount too large"
    //     payment = require_payment(Txn.sender)
    //     assert payment >= bet_amount, "payment insufficient"
    //     extra_payment = payment - bet_amount
    //     assert (
    //         extra_payment >= BOX_COST_BET
    //     ), "extra payment must be greater than box cost"
    //     assert (
    //         extra_payment <= MAX_EXTRA_PAYMENT
    //     ), "extra payment must be less than max extra payment"
    //     # lock spin if balance total is less than min bank amount
    //     assert (
    //         self.balance_total >= self.min_bank_amount
    //     ), "balance total must be greater than min bank amount"
    //     # Update balance tracking
    //     #   Add bet amount to total balance
    //     self.balance_total += bet_amount
    //     self.balance_available += bet_amount  # Add bet amount to available first
    //     max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    //     self.balance_locked += max_possible_payout
    //     # prevent underflow, impossible because it would err with result would be negative but good to have
    //     assert (
    //         self.balance_available >= max_possible_payout
    //     ), "balance available must be greater than max possible payout"
    //     self.balance_available -= max_possible_payout
    //     # Create bet
    //     confirmed_round = Global.round
    //     bet_key = self._get_bet_key(Txn.sender, bet_amount, provider_id, index)
    //     assert bet_key not in self.bet, "bet already exists"
    //     claim_round = confirmed_round + ROUND_FUTURE_DELTA
    //     self.bet[bet_key] = Bet(
    //         who=arc4.Address(Txn.sender),
    //         amount=arc4.UInt64(bet_amount),
    //         confirmed_round=arc4.UInt64(confirmed_round),
    //         index=arc4.UInt64(index),
    //         claim_round=arc4.UInt64(claim_round),
    //     )
    //     arc4.emit(
    //         BetPlaced(
    //             who=arc4.Address(Txn.sender),
    //             amount=arc4.UInt64(bet_amount),
    //             confirmed_round=arc4.UInt64(confirmed_round),
    //             index=arc4.UInt64(index),
    //             claim_round=arc4.UInt64(claim_round),
    //         )
    //     )
    //     return bet_key
    // 
    // # override
    // @subroutine
    // def _claim(self, bet_key: Bytes) -> UInt64:
    //     """
    //     Claim a bet
    //     Args:
    //         bet_key: The key of the bet to claim
    // 
    //     Returns:
    //         payout: The payout for the bet
    //     """
    //     assert bet_key in self.bet, "bet not found"
    frame_dig -1
    box_len
    bury 1
    // src/src/contract.py:757
    // assert bet_key in self.bet, "bet not found"
    assert // bet not found
    // src/src/contract.py:758
    // bet = self.bet[bet_key].copy()
    frame_dig -1
    box_get
    swap
    dup
    uncover 2
    assert // check self.bet entry exists
    // src/src/contract.py:759-761
    // # if round is greater than claim_round + MAX_CLAIM_ROUND_DELTA, the bet is expired
    // # and we can return the box cost to the sender
    // if Global.round > bet.claim_round.native + MAX_CLAIM_ROUND_DELTA:
    global Round
    swap
    extract 56 8 // on error: Index access is out of bounds
    dup
    cover 2
    btoi
    dup
    cover 2
    int 1000
    +
    >
    bz _claim_else_body@3
    // src/src/contract.py:762
    // del self.bet[bet_key]
    frame_dig -1
    box_del
    pop
    // src/src/contract.py:763-765
    // # Update balance tracking
    // #   Release locked balance and adjust available balance
    // max_possible_payout = bet.amount.native * UInt64(MAX_PAYOUT_MULTIPLIER)
    frame_dig 3
    dup
    extract 32 8 // on error: Index access is out of bounds
    dup
    btoi
    int 100
    *
    // src/src/contract.py:766
    // self.balance_locked -= max_possible_payout
    int 0
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:766
    // self.balance_locked -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    -
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:766
    // self.balance_locked -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:767
    // self.balance_available += max_possible_payout
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:767
    // self.balance_available += max_possible_payout
    app_global_get_ex
    assert // check self.balance_available exists
    +
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:767
    // self.balance_available += max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:768
    // itxn.Payment(receiver=Txn.sender, amount=BOX_COST_BET).submit()
    itxn_begin
    txn Sender
    int 37700
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:771
    // who=bet.who,
    dig 1
    extract 0 32 // on error: Index access is out of bounds
    swap
    // src/src/contract.py:773
    // confirmed_round=bet.confirmed_round,
    dig 2
    extract 40 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:774
    // index=bet.index,
    uncover 3
    extract 48 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:770-777
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=arc4.UInt64(0),
    // )
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig 4
    concat
    // src/src/contract.py:776
    // payout=arc4.UInt64(0),
    byte 0x0000000000000000
    // src/src/contract.py:770-777
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=arc4.UInt64(0),
    // )
    concat
    // src/src/contract.py:769-778
    // arc4.emit(
    //     BetClaimed(
    //         who=bet.who,
    //         amount=bet.amount,
    //         confirmed_round=bet.confirmed_round,
    //         index=bet.index,
    //         claim_round=bet.claim_round,
    //         payout=arc4.UInt64(0),
    //     )
    // )
    method "BetClaimed(address,uint64,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:779
    // return UInt64(0)
    int 0
    frame_bury 0
    retsub

_claim_else_body@3:
    // src/src/contract.py:783-784
    // # calculate r from block seed and bet key
    // combined = self._get_block_seed(bet.claim_round.native) + bet_key
    frame_dig 5
    callsub _get_block_seed
    frame_dig -1
    concat
    // src/src/contract.py:785
    // hashed = op.sha256(combined)
    sha256
    // src/src/contract.py:788
    // arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    byte 0x3b9aca00
    b%
    // src/src/contract.py:787-789
    // arc4.UInt256(
    //     arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    // ).bytes[-8:]
    dup
    len
    int 32
    <=
    assert // overflow
    int 32
    bzero
    b|
    dup
    len
    int 8
    dig 1
    >=
    int 8
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    // src/src/contract.py:786-790
    // r = arc4.UInt64.from_bytes(
    //     arc4.UInt256(
    //         arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    //     ).bytes[-8:]
    // )
    swap
    // src/src/contract.py:787-789
    // arc4.UInt256(
    //     arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    // ).bytes[-8:]
    substring3
    // src/src/contract.py:797
    // self._calculate_bet_payout(bet.amount.native, r.native)
    frame_dig 3
    extract 32 8 // on error: Index access is out of bounds
    dup
    frame_bury 1
    btoi
    swap
    btoi
    dig 1
    swap
    callsub _calculate_bet_payout
    // src/src/contract.py:791-798
    // #########################################################
    // # get payout internal if subclass of SlotMachinePayoutModel
    // # otherwise call model to get payout
    // #########################################################
    // # use embedded payout model
    // payout = arc4.UInt64(
    //     self._calculate_bet_payout(bet.amount.native, r.native)
    // )
    itob
    dup
    cover 2
    frame_bury 0
    // src/src/contract.py:799-809
    // # use remote payout model
    // # payout, txn = arc4.abi_call(
    // #     SlotMachinePayoutModelInterface.get_payout,
    // #     bet.amount,
    // #     r,
    // #     app_id=Application(self.payout_model),
    // # )
    // #########################################################
    // # Update balance tracking
    // #   Release locked balance and adjust available balance
    // max_possible_payout = bet.amount.native * UInt64(MAX_PAYOUT_MULTIPLIER)
    int 100
    *
    // src/src/contract.py:810
    // self.balance_locked -= max_possible_payout
    int 0
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:810
    // self.balance_locked -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    -
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:810
    // self.balance_locked -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:811
    // self.balance_available += (
    int 0
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:811
    // self.balance_available += (
    app_global_get_ex
    assert // check self.balance_available exists
    // src/src/contract.py:812
    // max_possible_payout - payout.native
    dig 2
    btoi
    dup
    frame_bury 2
    uncover 2
    dig 1
    -
    // src/src/contract.py:811-813
    // self.balance_available += (
    //     max_possible_payout - payout.native
    // )  # Release locked funds minus payout
    uncover 2
    +
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:811-813
    // self.balance_available += (
    //     max_possible_payout - payout.native
    // )  # Release locked funds minus payout
    swap
    app_global_put
    // src/src/contract.py:814
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    int 0
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:814
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    app_global_get_ex
    assert // check self.balance_total exists
    swap
    -
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:814
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    swap
    app_global_put
    // src/src/contract.py:815
    // if payout > 0:
    byte 0x0000000000000000
    b>
    bz _claim_after_if_else@6
    // src/src/contract.py:816
    // itxn.Payment(receiver=bet.who.native, amount=payout.native).submit()
    itxn_begin
    frame_dig 3
    extract 0 32 // on error: Index access is out of bounds
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit

_claim_after_if_else@6:
    // src/src/contract.py:817
    // del self.bet[bet_key]
    frame_dig -1
    box_del
    pop
    // src/src/contract.py:818
    // itxn.Payment(receiver=Txn.sender, amount=BOX_COST_BET).submit()
    itxn_begin
    txn Sender
    int 37700
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:821
    // who=bet.who,
    frame_dig 3
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    // src/src/contract.py:823
    // confirmed_round=bet.confirmed_round,
    dup
    extract 40 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:824
    // index=bet.index,
    extract 48 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:820-827
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=payout,
    // )
    frame_dig 1
    concat
    swap
    concat
    swap
    concat
    frame_dig 4
    concat
    frame_dig 0
    concat
    // src/src/contract.py:819-828
    // arc4.emit(
    //     BetClaimed(
    //         who=bet.who,
    //         amount=bet.amount,
    //         confirmed_round=bet.confirmed_round,
    //         index=bet.index,
    //         claim_round=bet.claim_round,
    //         payout=payout,
    //     )
    // )
    method "BetClaimed(address,uint64,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:829
    // return payout.native
    frame_dig 2
    frame_bury 0
    retsub


// contract.SlotMachine._get_block_seed(round: uint64) -> bytes:
_get_block_seed:
    // src/src/contract.py:553-554
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    proto 1 1
    // src/src/contract.py:555
    // return op.Block.blk_seed(round)[-32:]
    frame_dig -1
    block BlkSeed
    dup
    len
    int 32
    dig 1
    >=
    int 32
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    swap
    substring3
    retsub


// contract.SlotMachine._calculate_bet_payout(bet_amount: uint64, r: uint64) -> uint64:
_calculate_bet_payout:
    // src/src/contract.py:610-611
    // @subroutine
    // def _calculate_bet_payout(self, bet_amount: UInt64, r: UInt64) -> UInt64:
    proto 2 1
    byte ""
    dup
    // src/src/contract.py:635
    // for index in urange(6):
    int 0

_calculate_bet_payout_for_header@1:
    // src/src/contract.py:635
    // for index in urange(6):
    frame_dig 2
    int 6
    <
    bz _calculate_bet_payout_after_for@6
    // src/src/contract.py:636
    // prob = payout_model.probabilities[index].native
    frame_dig 2
    int 8
    *
    dup
    frame_bury 0
    byte 0x0000000000014346000000000019418400000000007e47960000000000fc8f2c00000000027765ee0000000009dd97b9
    swap
    int 8
    extract3 // on error: Index access is out of bounds
    btoi
    dup
    frame_bury 1
    // src/src/contract.py:637
    // if r < prob:
    frame_dig -1
    >
    bz _calculate_bet_payout_after_if_else@4
    // src/src/contract.py:638
    // return bet_amount * payout_model.multipliers[index].native
    byte 0x000000000000006400000000000000320000000000000014000000000000000a00000000000000050000000000000002
    frame_dig 0
    int 8
    extract3 // on error: Index access is out of bounds
    btoi
    frame_dig -2
    *
    frame_bury 0
    retsub

_calculate_bet_payout_after_if_else@4:
    // src/src/contract.py:639
    // r -= prob
    frame_dig -1
    frame_dig 1
    -
    frame_bury -1
    // src/src/contract.py:635
    // for index in urange(6):
    frame_dig 2
    int 1
    +
    frame_bury 2
    b _calculate_bet_payout_for_header@1

_calculate_bet_payout_after_for@6:
    // src/src/contract.py:641
    // return UInt64(0)
    int 0
    frame_bury 0
    retsub


// opensubmarine.contracts.access.Ownable.contract.Ownable.transfer(new_owner: bytes) -> void:
transfer:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:34-35
    // @arc4.abimethod
    // def transfer(self, new_owner: arc4.Address) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:36
    // assert Txn.sender == self.owner, "must be owner"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:36
    // assert Txn.sender == self.owner, "must be owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // must be owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:37
    // arc4.emit(OwnershipTransferred(arc4.Address(self.owner), new_owner))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:37
    // arc4.emit(OwnershipTransferred(arc4.Address(self.owner), new_owner))
    app_global_get_ex
    assert // check self.owner exists
    frame_dig -1
    concat
    method "OwnershipTransferred(address,address)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:38
    // self.owner = new_owner.native
    frame_dig -1
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.set_version(contract_version: bytes, deployment_version: bytes) -> void:
set_version:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83-86
    // @arc4.abimethod
    // def set_version(
    //     self, contract_version: arc4.UInt64, deployment_version: arc4.UInt64
    // ) -> None:
    proto 2 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:87
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:87
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:88
    // arc4.emit(VersionUpdated(contract_version, deployment_version))
    frame_dig -2
    frame_dig -1
    concat
    method "VersionUpdated(uint64,uint64)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:89
    // self.contract_version = contract_version.native
    frame_dig -2
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:89
    // self.contract_version = contract_version.native
    swap
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:90
    // self.deployment_version = deployment_version.native
    frame_dig -1
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:90
    // self.deployment_version = deployment_version.native
    swap
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.approve_update(approval: bytes) -> void:
approve_update:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101-102
    // @arc4.abimethod
    // def approve_update(self, approval: arc4.Bool) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:103
    // assert Txn.sender == self.owner, "must be owner"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:103
    // assert Txn.sender == self.owner, "must be owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // must be owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:104
    // arc4.emit(UpdateApproved(arc4.Address(self.owner), approval))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:104
    // arc4.emit(UpdateApproved(arc4.Address(self.owner), approval))
    app_global_get_ex
    assert // check self.owner exists
    frame_dig -1
    concat
    method "UpdateApproved(address,bool)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:105
    // self.updatable = approval.native
    frame_dig -1
    int 0
    getbit
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:105
    // self.updatable = approval.native
    swap
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.grant_upgrader(upgrader: bytes) -> void:
grant_upgrader:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107-108
    // @arc4.abimethod
    // def grant_upgrader(self, upgrader: arc4.Address) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:109
    // assert Txn.sender == Global.creator_address, "must be creator"
    txn Sender
    global CreatorAddress
    ==
    assert // must be creator
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:110
    // arc4.emit(UpgraderGranted(arc4.Address(self.upgrader), upgrader))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:110
    // arc4.emit(UpgraderGranted(arc4.Address(self.upgrader), upgrader))
    app_global_get_ex
    assert // check self.upgrader exists
    frame_dig -1
    concat
    method "UpgraderGranted(address,address)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:111
    // self.upgrader = upgrader.native
    frame_dig -1
    app_global_put
    retsub


// opensubmarine.contracts.participation.Stakable.contract.Stakeable.set_delegate(delegate: bytes) -> void:
set_delegate:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:81-82
    // @arc4.abimethod
    // def set_delegate(self, delegate: arc4.Address) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:84
    // Txn.sender == self.owner or Txn.sender == Global.creator_address
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:84
    // Txn.sender == self.owner or Txn.sender == Global.creator_address
    app_global_get_ex
    assert // check self.owner exists
    ==
    bnz set_delegate_bool_true@2
    txn Sender
    global CreatorAddress
    ==
    bz set_delegate_bool_false@3

set_delegate_bool_true@2:
    int 1
    b set_delegate_bool_merge@4

set_delegate_bool_false@3:
    int 0

set_delegate_bool_merge@4:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:83-85
    // assert (
    //     Txn.sender == self.owner or Txn.sender == Global.creator_address
    // ), "must be owner or creator"
    assert // must be owner or creator
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:86
    // arc4.emit(DelegateUpdated(arc4.Address(self.delegate), delegate))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:86
    // arc4.emit(DelegateUpdated(arc4.Address(self.delegate), delegate))
    app_global_get_ex
    assert // check self.delegate exists
    frame_dig -1
    concat
    method "DelegateUpdated(address,address)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:87
    // self.delegate = delegate.native
    frame_dig -1
    app_global_put
    retsub


// opensubmarine.contracts.participation.Stakable.contract.Stakeable.participate(vote_k: bytes, sel_k: bytes, vote_fst: bytes, vote_lst: bytes, vote_kd: bytes, sp_key: bytes) -> void:
participate:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:89-98
    // @arc4.abimethod
    // def participate(
    //     self,
    //     vote_k: Bytes32,
    //     sel_k: Bytes32,
    //     vote_fst: arc4.UInt64,
    //     vote_lst: arc4.UInt64,
    //     vote_kd: arc4.UInt64,
    //     sp_key: Bytes64,
    // ) -> None:
    proto 6 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:101
    // Txn.sender == self.owner or Txn.sender == self.delegate
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:101
    // Txn.sender == self.owner or Txn.sender == self.delegate
    app_global_get_ex
    assert // check self.owner exists
    ==
    bnz participate_bool_true@2
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:101
    // Txn.sender == self.owner or Txn.sender == self.delegate
    app_global_get_ex
    assert // check self.delegate exists
    ==
    bz participate_bool_false@3

participate_bool_true@2:
    int 1
    b participate_bool_merge@4

participate_bool_false@3:
    int 0

participate_bool_merge@4:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:99-102
    // ###########################################
    // assert (
    //     Txn.sender == self.owner or Txn.sender == self.delegate
    // ), "must be owner or delegate"
    assert // must be owner or delegate
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:103-104
    // ###########################################
    // key_reg_fee = Global.min_txn_fee
    global MinTxnFee
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:105-106
    // # require payment of min fee to prevent draining
    // assert require_payment(Txn.sender) == key_reg_fee, "payment amout accurate"
    txn Sender
    callsub require_payment
    dig 1
    ==
    assert // payment amout accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:110
    // arc4.Address(Txn.sender),
    txn Sender
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:112
    // address=arc4.Address(Txn.sender),
    dup
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:111-119
    // PartKeyInfo(
    //     address=arc4.Address(Txn.sender),
    //     vote_key=vote_k,
    //     selection_key=sel_k,
    //     vote_first=vote_fst,
    //     vote_last=vote_lst,
    //     vote_key_dilution=vote_kd,
    //     state_proof_key=sp_key,
    // ),
    frame_dig -6
    concat
    frame_dig -5
    concat
    frame_dig -4
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    frame_dig -1
    concat
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:109-120
    // Participated(
    //     arc4.Address(Txn.sender),
    //     PartKeyInfo(
    //         address=arc4.Address(Txn.sender),
    //         vote_key=vote_k,
    //         selection_key=sel_k,
    //         vote_first=vote_fst,
    //         vote_last=vote_lst,
    //         vote_key_dilution=vote_kd,
    //         state_proof_key=sp_key,
    //     ),
    // )
    concat
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:107-121
    // ###########################################
    // arc4.emit(
    //     Participated(
    //         arc4.Address(Txn.sender),
    //         PartKeyInfo(
    //             address=arc4.Address(Txn.sender),
    //             vote_key=vote_k,
    //             selection_key=sel_k,
    //             vote_first=vote_fst,
    //             vote_last=vote_lst,
    //             vote_key_dilution=vote_kd,
    //             state_proof_key=sp_key,
    //         ),
    //     )
    // )
    method "Participated(address,(address,byte[32],byte[32],uint64,uint64,uint64,byte[64]))"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:122-130
    // itxn.KeyRegistration(
    //     vote_key=vote_k.bytes,
    //     selection_key=sel_k.bytes,
    //     vote_first=vote_fst.native,
    //     vote_last=vote_lst.native,
    //     vote_key_dilution=vote_kd.native,
    //     state_proof_key=sp_key.bytes,
    //     fee=key_reg_fee,
    // ).submit()
    itxn_begin
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:125
    // vote_first=vote_fst.native,
    frame_dig -4
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:126
    // vote_last=vote_lst.native,
    frame_dig -3
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:127
    // vote_key_dilution=vote_kd.native,
    frame_dig -2
    btoi
    frame_dig -1
    itxn_field StateProofPK
    itxn_field VoteKeyDilution
    itxn_field VoteLast
    itxn_field VoteFirst
    frame_dig -5
    itxn_field SelectionPK
    frame_dig -6
    itxn_field VotePK
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:122
    // itxn.KeyRegistration(
    int keyreg
    itxn_field TypeEnum
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:122-130
    // itxn.KeyRegistration(
    //     vote_key=vote_k.bytes,
    //     selection_key=sel_k.bytes,
    //     vote_first=vote_fst.native,
    //     vote_last=vote_lst.native,
    //     vote_key_dilution=vote_kd.native,
    //     state_proof_key=sp_key.bytes,
    //     fee=key_reg_fee,
    // ).submit()
    itxn_submit
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.on_update() -> void:
on_update:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92-93
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def on_update(self) -> None:
    proto 0 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:94-97
    // ##########################################
    // # WARNING: This app can be updated by the creator
    // ##########################################
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:94-97
    // ##########################################
    // # WARNING: This app can be updated by the creator
    // ##########################################
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:98
    // assert self.updatable == UInt64(1), "not approved"
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:98
    // assert self.updatable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.updatable exists
    int 1
    ==
    assert // not approved
    retsub


// contract.Deleteable.on_delete() -> void:
on_delete:
    // src/src/contract.py:58-59
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    // def on_delete(self) -> None:  # pragma: no cover
    proto 0 0
    // src/src/contract.py:60-63
    // ##########################################
    // # WARNING: This app can be deleted by the creator (Development)
    // ##########################################
    // assert Txn.sender == Global.creator_address, "must be creator"
    txn Sender
    global CreatorAddress
    ==
    assert // must be creator
    // src/src/contract.py:64
    // assert self.deletable == UInt64(1), "not approved"
    int 0
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:64
    // assert self.deletable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.deletable exists
    int 1
    ==
    assert // not approved
    retsub


// contract.SlotMachine.__init__() -> void:
__init__:
    // src/src/contract.py:424
    // def __init__(self) -> None:
    proto 0 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // src/src/contract.py:425-426
    // # ownable state
    // self.owner = Global.creator_address  # set owner to creator
    global CreatorAddress
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:47
    // self.delegate = Account()
    byte "delegate"
    // src/src/contract.py:427-428
    // # stakeable state
    // self.delegate = Account()  # zero address
    global ZeroAddress
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/participation/Stakable/contract.py:48
    // self.stakeable = bool(1)
    byte "stakeable"
    // src/src/contract.py:429
    // self.stakeable = bool(1)  # 1 (Default unlocked)
    int 1
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // src/src/contract.py:430-431
    // # upgradable state
    // self.contract_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // src/src/contract.py:432
    // self.deployment_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:433
    // self.updatable = bool(1)
    int 1
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:434
    // self.upgrader = Global.creator_address
    global CreatorAddress
    app_global_put
    // src/src/contract.py:44
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:435-436
    // # deleteable state
    // self.deletable = bool(1)
    int 1
    app_global_put
    // src/src/contract.py:437-438
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    int 0
    app_global_put
    // src/src/contract.py:439
    // self.balance_available = UInt64()
    byte "balance_available"
    int 0
    app_global_put
    // src/src/contract.py:440
    // self.balance_locked = UInt64()
    byte "balance_locked"
    int 0
    app_global_put
    // src/src/contract.py:441
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    int 1000000
    app_global_put
    // src/src/contract.py:442
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    int 1000000000
    app_global_put
    // src/src/contract.py:443
    // self.min_bank_amount = UInt64(MIN_BANK_AMOUNT)  # 350,000 VOI
    byte "min_bank_amount"
    int 350000000000
    app_global_put
    // src/src/contract.py:444
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    int 0
    app_global_put
    retsub
