#pragma version 10

contract.SlotMachine.approval_program:
    txn ApplicationID
    bnz main_entrypoint@2
    callsub __init__

main_entrypoint@2:
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txn NumAppArgs
    bz main_bare_routing@20
    method "post_upgrade()void"
    method "set_payout_model(uint64)void"
    method "set_min_bet_amount(uint64)void"
    method "set_max_bet_amount(uint64)void"
    method "deposit()void"
    method "withdraw(uint64)void"
    method "get_bet_key(address,uint64,uint64,uint64)byte[56]"
    method "kill()void"
    method "spin(uint64,uint64)byte[56]"
    method "claim(byte[56])uint64"
    method "set_version(uint64,uint64)void"
    method "approve_update(bool)void"
    method "grant_upgrader(address)void"
    method "transfer(address)void"
    txna ApplicationArgs 0
    match main_post_upgrade_route@4 main_set_payout_model_route@5 main_set_min_bet_amount_route@6 main_set_max_bet_amount_route@7 main_deposit_route@8 main_withdraw_route@9 main_get_bet_key_route@10 main_kill_route@11 main_spin_route@12 main_claim_route@13 main_set_version_route@14 main_approve_update_route@15 main_grant_upgrader_route@16 main_transfer_route@17
    err // reject transaction

main_post_upgrade_route@4:
    // src/src/contract.py:344
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub post_upgrade
    int 1
    return

main_set_payout_model_route@5:
    // src/src/contract.py:355
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:355
    // @arc4.abimethod
    callsub set_payout_model
    int 1
    return

main_set_min_bet_amount_route@6:
    // src/src/contract.py:364
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:364
    // @arc4.abimethod
    callsub set_min_bet_amount
    int 1
    return

main_set_max_bet_amount_route@7:
    // src/src/contract.py:376
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:376
    // @arc4.abimethod
    callsub set_max_bet_amount
    int 1
    return

main_deposit_route@8:
    // src/src/contract.py:396
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    callsub deposit
    int 1
    return

main_withdraw_route@9:
    // src/src/contract.py:406
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:406
    // @arc4.abimethod
    callsub withdraw
    int 1
    return

main_get_bet_key_route@10:
    // src/src/contract.py:424
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // src/src/contract.py:424
    // @arc4.abimethod
    callsub get_bet_key
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_kill_route@11:
    // src/src/contract.py:449
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    txn OnCompletion
    int DeleteApplication
    ==
    assert // OnCompletion is DeleteApplication
    txn ApplicationID
    assert // is not creating
    callsub kill
    int 1
    return

main_spin_route@12:
    // src/src/contract.py:250
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // src/src/contract.py:250
    // @arc4.abimethod
    callsub spin
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_claim_route@13:
    // src/src/contract.py:282
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    // src/src/contract.py:282
    // @arc4.abimethod
    callsub claim
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_set_version_route@14:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83
    // @arc4.abimethod
    callsub set_version
    int 1
    return

main_approve_update_route@15:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101
    // @arc4.abimethod
    callsub approve_update
    int 1
    return

main_grant_upgrader_route@16:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txna ApplicationArgs 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107
    // @arc4.abimethod
    callsub grant_upgrader
    int 1
    return

main_transfer_route@17:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:22
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    int 1
    return

main_bare_routing@20:
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txn OnCompletion
    switch main_create@21 main_reject_bare_on_completion@24 main_reject_bare_on_completion@24 main_reject_bare_on_completion@24 main_on_update@22 main_on_delete@23
    err // reject transaction

main_create@21:
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    txn ApplicationID
    !
    assert // is creating
    int 1
    return

main_on_update@22:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    txn ApplicationID
    assert // is not creating
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92-93
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def on_update(self) -> None:
    callsub on_update
    int 1
    return

main_on_delete@23:
    // src/src/contract.py:57
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    txn ApplicationID
    assert // is not creating
    // src/src/contract.py:57-58
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    // def on_delete(self) -> None:  # pragma: no cover
    callsub on_delete
    int 1
    return

main_reject_bare_on_completion@24:
    // src/src/contract.py:309
    // class SlotMachine(SlotMachineInterface, Upgradeable, Deleteable):
    err // reject transaction


// contract.SlotMachine.post_upgrade() -> void:
post_upgrade:
    // src/src/contract.py:344-345
    // @arc4.abimethod
    // def post_upgrade(self) -> None:
    proto 0 0
    // src/src/contract.py:349
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:349
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // src/src/contract.py:350
    // self.contract_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // src/src/contract.py:351
    // self.deployment_version = UInt64()
    int 0
    app_global_put
    retsub


// contract.SlotMachine.set_payout_model(app_id: bytes) -> void:
set_payout_model:
    // src/src/contract.py:355-356
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:360
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:361
    // assert app_id.native > 0, "app id must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // app id must be greater than 0
    // src/src/contract.py:330
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    // src/src/contract.py:362
    // self.payout_model = app_id.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.only_owner() -> void:
only_owner:
    // src/src/contract.py:335-336
    // @subroutine
    // def only_owner(self) -> None:
    proto 0 0
    // src/src/contract.py:340
    // assert Txn.sender == self.owner, "only owner can call this function"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // src/src/contract.py:340
    // assert Txn.sender == self.owner, "only owner can call this function"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // only owner can call this function
    retsub


// contract.SlotMachine.set_min_bet_amount(min_bet_amount: bytes) -> void:
set_min_bet_amount:
    // src/src/contract.py:364-365
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:369
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:370
    // assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // min bet amount must be greater than 0
    // src/src/contract.py:372
    // min_bet_amount.native <= self.max_bet_amount
    int 0
    // src/src/contract.py:329
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:372
    // min_bet_amount.native <= self.max_bet_amount
    app_global_get_ex
    assert // check self.max_bet_amount exists
    dig 1
    >=
    // src/src/contract.py:371-373
    // assert (
    //     min_bet_amount.native <= self.max_bet_amount
    // ), "min bet amount must be less than max bet amount"
    assert // min bet amount must be less than max bet amount
    // src/src/contract.py:328
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:374
    // self.min_bet_amount = min_bet_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.set_max_bet_amount(max_bet_amount: bytes) -> void:
set_max_bet_amount:
    // src/src/contract.py:376-377
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:381
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:382
    // assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // max bet amount must be greater than 0
    // src/src/contract.py:384
    // max_bet_amount.native >= self.min_bet_amount
    int 0
    // src/src/contract.py:328
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:384
    // max_bet_amount.native >= self.min_bet_amount
    app_global_get_ex
    assert // check self.min_bet_amount exists
    dig 1
    <=
    // src/src/contract.py:383-385
    // assert (
    //     max_bet_amount.native >= self.min_bet_amount
    // ), "max bet amount must be greater than min bet amount"
    assert // max bet amount must be greater than min bet amount
    // src/src/contract.py:329
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:386
    // self.max_bet_amount = max_bet_amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.deposit() -> void:
deposit:
    // src/src/contract.py:396-397
    // @arc4.abimethod
    // def deposit(self) -> None:
    proto 0 0
    // src/src/contract.py:401
    // payment = require_payment(Txn.sender)
    txn Sender
    callsub require_payment
    // src/src/contract.py:402
    // assert payment > 0, "payment must be greater than 0"
    dup
    assert // payment must be greater than 0
    // src/src/contract.py:403
    // self.balance_total += payment
    int 0
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:403
    // self.balance_total += payment
    app_global_get_ex
    assert // check self.balance_total exists
    dig 1
    +
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:403
    // self.balance_total += payment
    swap
    app_global_put
    // src/src/contract.py:404
    // self.balance_available += payment
    int 0
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:404
    // self.balance_available += payment
    app_global_get_ex
    assert // check self.balance_available exists
    +
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:404
    // self.balance_available += payment
    swap
    app_global_put
    retsub


// opensubmarine.utils.algorand.require_payment(who: bytes) -> uint64:
require_payment:
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:15-23
    // ##############################################
    // # function: require_payment (internal)
    // # arguments: None
    // # purpose: check payment
    // # pre-conditions: None
    // # post-conditions: None
    // ##############################################
    // @subroutine
    // def require_payment(who: Account) -> UInt64:
    proto 1 1
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:24
    // ref_group_index = Txn.group_index
    txn GroupIndex
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:25
    // assert ref_group_index > 0, "group index greater than zero"
    dup
    assert // group index greater than zero
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:26
    // payment_group_index = ref_group_index - 1
    int 1
    -
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:28
    // gtxn.PaymentTransaction(payment_group_index).sender == who
    dup
    gtxns TypeEnum
    int pay
    ==
    assert // transaction type is pay
    dup
    gtxns Sender
    frame_dig -1
    ==
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:27-29
    // assert (
    //     gtxn.PaymentTransaction(payment_group_index).sender == who
    // ), "payment sender accurate"
    assert // payment sender accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:31
    // gtxn.PaymentTransaction(payment_group_index).receiver
    dup
    gtxns Receiver
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:32
    // == Global.current_application_address
    global CurrentApplicationAddress
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:31-32
    // gtxn.PaymentTransaction(payment_group_index).receiver
    // == Global.current_application_address
    ==
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:30-33
    // assert (
    //     gtxn.PaymentTransaction(payment_group_index).receiver
    //     == Global.current_application_address
    // ), "payment receiver accurate"
    assert // payment receiver accurate
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:34
    // return gtxn.PaymentTransaction(payment_group_index).amount
    gtxns Amount
    retsub


// contract.SlotMachine.withdraw(amount: bytes) -> void:
withdraw:
    // src/src/contract.py:406-407
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    proto 1 0
    // src/src/contract.py:415
    // self.only_owner()
    callsub only_owner
    // src/src/contract.py:416
    // assert amount.native > UInt64(0), "amount must be greater than 0"
    frame_dig -1
    btoi
    dup
    assert // amount must be greater than 0
    // src/src/contract.py:417
    // assert amount.native <= self.balance_available, "insufficient balance"
    int 0
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:417
    // assert amount.native <= self.balance_available, "insufficient balance"
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    >=
    assert // insufficient balance
    // src/src/contract.py:418
    // itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    itxn_begin
    txn Sender
    dig 1
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:419
    // self.balance_available -= amount.native
    int 0
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:419
    // self.balance_available -= amount.native
    app_global_get_ex
    assert // check self.balance_available exists
    dig 1
    -
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:419
    // self.balance_available -= amount.native
    swap
    app_global_put
    // src/src/contract.py:420
    // self.balance_total -= amount.native
    int 0
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:420
    // self.balance_total -= amount.native
    app_global_get_ex
    assert // check self.balance_total exists
    swap
    -
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:420
    // self.balance_total -= amount.native
    swap
    app_global_put
    retsub


// contract.SlotMachine.get_bet_key(address: bytes, amount: bytes, round: bytes, index: bytes) -> bytes:
get_bet_key:
    // src/src/contract.py:424-431
    // @arc4.abimethod
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    proto 4 1
    // src/src/contract.py:433
    // self._get_bet_key(address.native, amount.native, round.native, index.native)
    frame_dig -3
    btoi
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    frame_dig -4
    cover 3
    callsub _get_bet_key
    // src/src/contract.py:432-434
    // return Bytes56.from_bytes(
    //     self._get_bet_key(address.native, amount.native, round.native, index.native)
    // )
    retsub


// contract.SlotMachine._get_bet_key(address: bytes, amount: uint64, round: uint64, index: uint64) -> bytes:
_get_bet_key:
    // src/src/contract.py:436-439
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    proto 4 1
    // src/src/contract.py:442
    // + arc4.UInt64(amount).bytes
    frame_dig -3
    itob
    // src/src/contract.py:441-442
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    frame_dig -4
    swap
    concat
    // src/src/contract.py:443
    // + arc4.UInt64(round).bytes
    frame_dig -2
    itob
    // src/src/contract.py:441-443
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    // + arc4.UInt64(round).bytes
    concat
    // src/src/contract.py:444
    // + arc4.UInt64(index).bytes
    frame_dig -1
    itob
    // src/src/contract.py:441-444
    // arc4.Address(address).bytes
    // + arc4.UInt64(amount).bytes
    // + arc4.UInt64(round).bytes
    // + arc4.UInt64(index).bytes
    concat
    // src/src/contract.py:440-445
    // return (
    //     arc4.Address(address).bytes
    //     + arc4.UInt64(amount).bytes
    //     + arc4.UInt64(round).bytes
    //     + arc4.UInt64(index).bytes
    // )
    retsub


// contract.SlotMachine.kill() -> void:
kill:
    // src/src/contract.py:449-450
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    proto 0 0
    // src/src/contract.py:454
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:454
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // src/src/contract.py:455
    // assert self.updatable == UInt64(1), "not approved"
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:455
    // assert self.updatable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.updatable exists
    int 1
    ==
    assert // not approved
    // src/src/contract.py:456
    // assert self.balance_locked == UInt64(0), "balance locked must be 0"
    int 0
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:456
    // assert self.balance_locked == UInt64(0), "balance locked must be 0"
    app_global_get_ex
    assert // check self.balance_locked exists
    !
    assert // balance locked must be 0
    // src/src/contract.py:457
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:457
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    app_global_get_ex
    assert // check self.upgrader exists
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:457
    // arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    app_global_get_ex
    assert // check self.upgrader exists
    concat
    method "Closed(address,address)"
    swap
    concat
    log
    // src/src/contract.py:458
    // close_offline_on_delete(self.upgrader)
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:458
    // close_offline_on_delete(self.upgrader)
    app_global_get_ex
    assert // check self.upgrader exists
    callsub close_offline_on_delete
    retsub


// opensubmarine.utils.algorand.close_offline_on_delete(close_remainder_to: bytes) -> void:
close_offline_on_delete:
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:50-52
    // ##############################################
    // @subroutine
    // def close_offline_on_delete(close_remainder_to: Account) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:53
    // oca = Txn.on_completion
    txn OnCompletion
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:54
    // if oca == OnCompleteAction.DeleteApplication:
    int DeleteApplication
    ==
    assert
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:70
    // receiver=Global.creator_address,
    global CreatorAddress
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:73
    // amount=op.Global.min_balance,
    global MinBalance
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_begin
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:64-66
    // state_proof_key=Bytes.from_base64(
    //     "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
    // ),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
    itxn_field StateProofPK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:63
    // vote_key_dilution=UInt64(0),
    int 0
    itxn_field VoteKeyDilution
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:62
    // vote_last=UInt64(0),
    int 0
    itxn_field VoteLast
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:61
    // vote_first=UInt64(0),
    int 0
    itxn_field VoteFirst
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:58-60
    // selection_key=Bytes.from_base64(
    //     "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
    // ),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
    itxn_field SelectionPK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:57
    // vote_key=Bytes.from_base64("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="),
    byte base64 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
    itxn_field VotePK
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:56
    // non_participation=True,
    int 1
    itxn_field Nonparticipation
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:55
    // keyreg_txn = itxn.KeyRegistration(
    int keyreg
    itxn_field TypeEnum
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:67
    // fee=0,
    int 0
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_next
    itxn_field Amount
    frame_dig -1
    itxn_field CloseRemainderTo
    itxn_field Receiver
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:69
    // pmt_txn = itxn.Payment(
    int pay
    itxn_field TypeEnum
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:72
    // fee=0,
    int 0
    itxn_field Fee
    // usr/local/lib/python3.12/site-packages/opensubmarine/utils/algorand.py:75
    // itxn.submit_txns(keyreg_txn, pmt_txn)
    itxn_submit
    retsub


// contract.SlotMachineInterface.spin(bet_amount: bytes, index: bytes) -> bytes:
spin:
    // src/src/contract.py:250-251
    // @arc4.abimethod
    // def spin(self, bet_amount: arc4.UInt64, index: arc4.UInt64) -> Bytes56:
    proto 2 1
    // src/src/contract.py:263
    // return Bytes56.from_bytes(self._spin(bet_amount.native, index.native))
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    callsub _spin
    retsub


// contract.SlotMachine._spin(bet_amount: uint64, index: uint64) -> bytes:
_spin:
    // src/src/contract.py:481-483
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, index: UInt64) -> Bytes:
    proto 2 1
    // src/src/contract.py:495
    // assert bet_amount >= self.min_bet_amount, "bet amount too small"
    int 0
    // src/src/contract.py:328
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    // src/src/contract.py:495
    // assert bet_amount >= self.min_bet_amount, "bet amount too small"
    app_global_get_ex
    assert // check self.min_bet_amount exists
    frame_dig -2
    <=
    assert // bet amount too small
    // src/src/contract.py:496
    // assert bet_amount <= self.max_bet_amount, "bet amount too large"
    int 0
    // src/src/contract.py:329
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    // src/src/contract.py:496
    // assert bet_amount <= self.max_bet_amount, "bet amount too large"
    app_global_get_ex
    assert // check self.max_bet_amount exists
    frame_dig -2
    >=
    assert // bet amount too large
    // src/src/contract.py:497
    // payment = require_payment(Txn.sender)
    txn Sender
    callsub require_payment
    // src/src/contract.py:498
    // assert payment >= bet_amount, "payment insufficient"
    dup
    frame_dig -2
    >=
    assert // payment insufficient
    // src/src/contract.py:499
    // extra_payment = payment - bet_amount
    frame_dig -2
    -
    // src/src/contract.py:501
    // extra_payment >= BOX_COST_BET
    dup
    int 37700
    >=
    // src/src/contract.py:500-502
    // assert (
    //     extra_payment >= BOX_COST_BET
    // ), "extra payment must be greater than box cost"
    assert // extra payment must be greater than box cost
    // src/src/contract.py:504
    // extra_payment <= MAX_EXTRA_PAYMENT
    int 1000000
    <=
    // src/src/contract.py:503-505
    // assert (
    //     extra_payment <= MAX_EXTRA_PAYMENT
    // ), "extra payment must be less than max extra payment"
    assert // extra payment must be less than max extra payment
    // src/src/contract.py:506-508
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    int 0
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:506-508
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    app_global_get_ex
    assert // check self.balance_total exists
    frame_dig -2
    +
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:506-508
    // # Update balance tracking
    // #   Add bet amount to total balance
    // self.balance_total += bet_amount
    swap
    app_global_put
    // src/src/contract.py:509
    // self.balance_available += bet_amount  # Add bet amount to available first
    int 0
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:509
    // self.balance_available += bet_amount  # Add bet amount to available first
    app_global_get_ex
    assert // check self.balance_available exists
    frame_dig -2
    +
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:509
    // self.balance_available += bet_amount  # Add bet amount to available first
    swap
    app_global_put
    // src/src/contract.py:510
    // max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    frame_dig -2
    int 100
    *
    // src/src/contract.py:511
    // self.balance_locked += max_possible_payout
    int 0
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:511
    // self.balance_locked += max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    +
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:511
    // self.balance_locked += max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:512
    // self.balance_available -= max_possible_payout
    int 0
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:512
    // self.balance_available -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_available exists
    swap
    -
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:512
    // self.balance_available -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:513-514
    // # Create bet
    // round = Global.round
    global Round
    // src/src/contract.py:515
    // bet_key = self._get_bet_key(Txn.sender, bet_amount, round, index)
    txn Sender
    frame_dig -2
    dig 2
    frame_dig -1
    callsub _get_bet_key
    // src/src/contract.py:331-516
    //     self.bet = BoxMap(Bytes, Bet, key_prefix="")
    // 
    // # guard methods
    // 
    // @subroutine
    // def only_owner(self) -> None:
    //     """
    //     Only callable by contract owner
    //     """
    //     assert Txn.sender == self.owner, "only owner can call this function"
    // 
    // # upgradeable methods
    // 
    // @arc4.abimethod
    // def post_upgrade(self) -> None:
    //     """
    //     Called after upgrade
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     self.contract_version = UInt64()
    //     self.deployment_version = UInt64()
    // 
    // # owner methods
    // 
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    //     """
    //     Set the payout model
    //     """
    //     self.only_owner()
    //     assert app_id.native > 0, "app id must be greater than 0"
    //     self.payout_model = app_id.native
    // 
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bet amount
    //     """
    //     self.only_owner()
    //     assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    //     assert (
    //         min_bet_amount.native <= self.max_bet_amount
    //     ), "min bet amount must be less than max bet amount"
    //     self.min_bet_amount = min_bet_amount.native
    // 
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the maximum bet amount
    //     """
    //     self.only_owner()
    //     assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    //     assert (
    //         max_bet_amount.native >= self.min_bet_amount
    //     ), "max bet amount must be greater than min bet amount"
    //     self.max_bet_amount = max_bet_amount.native
    // 
    // # block seed utils
    // 
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    //     return op.Block.blk_seed(round)[-32:]
    // 
    // # bankroll management
    // 
    // @arc4.abimethod
    // def deposit(self) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     payment = require_payment(Txn.sender)
    //     assert payment > 0, "payment must be greater than 0"
    //     self.balance_total += payment
    //     self.balance_available += payment
    // 
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    //     """
    //     Withdraw funds from the contract
    //     Only callable by contract owner
    // 
    //     Args:
    //         amount: The amount of funds to withdraw in atomic units
    //     """
    //     self.only_owner()
    //     assert amount.native > UInt64(0), "amount must be greater than 0"
    //     assert amount.native <= self.balance_available, "insufficient balance"
    //     itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    //     self.balance_available -= amount.native
    //     self.balance_total -= amount.native
    // 
    // # bet key utils
    // 
    // @arc4.abimethod
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    //     return Bytes56.from_bytes(
    //         self._get_bet_key(address.native, amount.native, round.native, index.native)
    //     )
    // 
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    //     return (
    //         arc4.Address(address).bytes
    //         + arc4.UInt64(amount).bytes
    //         + arc4.UInt64(round).bytes
    //         + arc4.UInt64(index).bytes
    //     )
    // 
    // # terminal methods
    // 
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    //     """
    //     Kill the contract
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     assert self.updatable == UInt64(1), "not approved"
    //     assert self.balance_locked == UInt64(0), "balance locked must be 0"
    //     arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    //     close_offline_on_delete(self.upgrader)
    // 
    // # slot machine methods
    // 
    // # @arc4.abimethod
    // # def spin(
    // #     self,
    // #     bet_amount: arc4.UInt64,
    // #     index: arc4.UInt64,
    // # ) -> Bytes56:
    // #     """
    // #     Spin the slot machine. Outcome is determined by the seed
    // #     of future round.
    // 
    // #     Args:
    // #         bet (uint): The player's wager.
    // #         index (uint): Player's choice of index.
    // 
    // #     Returns:
    // #         r (uint): The round number of the spin.
    // #     """
    // #     return Bytes56.from_bytes(self._spin(bet_amount.native, index.native))
    // 
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, index: UInt64) -> Bytes:
    //     """
    //     Spin the slot machine. Outcome is determined by the seed
    //     of future round.
    // 
    //     Args:
    //         bet (uint): The player's wager.
    //         index (uint): Player's choice of index.
    // 
    //     Returns:
    //         r (uint): The round number of the spin.
    //     """
    //     assert bet_amount >= self.min_bet_amount, "bet amount too small"
    //     assert bet_amount <= self.max_bet_amount, "bet amount too large"
    //     payment = require_payment(Txn.sender)
    //     assert payment >= bet_amount, "payment insufficient"
    //     extra_payment = payment - bet_amount
    //     assert (
    //         extra_payment >= BOX_COST_BET
    //     ), "extra payment must be greater than box cost"
    //     assert (
    //         extra_payment <= MAX_EXTRA_PAYMENT
    //     ), "extra payment must be less than max extra payment"
    //     # Update balance tracking
    //     #   Add bet amount to total balance
    //     self.balance_total += bet_amount
    //     self.balance_available += bet_amount  # Add bet amount to available first
    //     max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    //     self.balance_locked += max_possible_payout
    //     self.balance_available -= max_possible_payout
    //     # Create bet
    //     round = Global.round
    //     bet_key = self._get_bet_key(Txn.sender, bet_amount, round, index)
    //     assert bet_key not in self.bet, "bet already exists"
    dup
    box_len
    bury 1
    !
    // src/src/contract.py:516
    // assert bet_key not in self.bet, "bet already exists"
    assert // bet already exists
    // src/src/contract.py:517
    // claim_round = round + ROUND_FUTURE_DELTA
    dig 1
    int 1
    +
    swap
    // src/src/contract.py:519
    // who=arc4.Address(Txn.sender),
    txn Sender
    cover 2
    // src/src/contract.py:520
    // amount=arc4.UInt64(bet_amount),
    frame_dig -2
    itob
    swap
    // src/src/contract.py:521
    // confirmed_round=arc4.UInt64(round),
    uncover 4
    itob
    cover 2
    // src/src/contract.py:522
    // index=arc4.UInt64(index),
    frame_dig -1
    itob
    cover 4
    // src/src/contract.py:523
    // claim_round=arc4.UInt64(claim_round),
    uncover 3
    itob
    cover 4
    // src/src/contract.py:518-524
    // self.bet[bet_key] = Bet(
    //     who=arc4.Address(Txn.sender),
    //     amount=arc4.UInt64(bet_amount),
    //     confirmed_round=arc4.UInt64(round),
    //     index=arc4.UInt64(index),
    //     claim_round=arc4.UInt64(claim_round),
    // )
    uncover 5
    dig 2
    concat
    dig 3
    concat
    dig 4
    concat
    dig 5
    concat
    dig 1
    swap
    box_put
    // src/src/contract.py:527
    // who=arc4.Address(Txn.sender),
    txn Sender
    // src/src/contract.py:526-532
    // BetPlaced(
    //     who=arc4.Address(Txn.sender),
    //     amount=arc4.UInt64(bet_amount),
    //     confirmed_round=arc4.UInt64(round),
    //     index=arc4.UInt64(index),
    //     claim_round=arc4.UInt64(claim_round),
    // )
    uncover 2
    concat
    uncover 2
    concat
    uncover 2
    concat
    uncover 2
    concat
    // src/src/contract.py:525-533
    // arc4.emit(
    //     BetPlaced(
    //         who=arc4.Address(Txn.sender),
    //         amount=arc4.UInt64(bet_amount),
    //         confirmed_round=arc4.UInt64(round),
    //         index=arc4.UInt64(index),
    //         claim_round=arc4.UInt64(claim_round),
    //     )
    // )
    method "BetPlaced(address,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:534
    // return bet_key
    retsub


// contract.SlotMachineInterface.claim(bet_key: bytes) -> bytes:
claim:
    // src/src/contract.py:282-283
    // @arc4.abimethod
    // def claim(self, bet_key: Bytes56) -> arc4.UInt64:
    proto 1 1
    // src/src/contract.py:293
    // return arc4.UInt64(self._claim(bet_key.bytes))
    frame_dig -1
    callsub _claim
    itob
    retsub


// contract.SlotMachine._claim(bet_key: bytes) -> uint64:
_claim:
    // src/src/contract.py:549-551
    // # override
    // @subroutine
    // def _claim(self, bet_key: Bytes) -> UInt64:
    proto 1 1
    int 0
    dup
    byte ""
    // src/src/contract.py:331-560
    //     self.bet = BoxMap(Bytes, Bet, key_prefix="")
    // 
    // # guard methods
    // 
    // @subroutine
    // def only_owner(self) -> None:
    //     """
    //     Only callable by contract owner
    //     """
    //     assert Txn.sender == self.owner, "only owner can call this function"
    // 
    // # upgradeable methods
    // 
    // @arc4.abimethod
    // def post_upgrade(self) -> None:
    //     """
    //     Called after upgrade
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     self.contract_version = UInt64()
    //     self.deployment_version = UInt64()
    // 
    // # owner methods
    // 
    // @arc4.abimethod
    // def set_payout_model(self, app_id: arc4.UInt64) -> None:
    //     """
    //     Set the payout model
    //     """
    //     self.only_owner()
    //     assert app_id.native > 0, "app id must be greater than 0"
    //     self.payout_model = app_id.native
    // 
    // @arc4.abimethod
    // def set_min_bet_amount(self, min_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the minimum bet amount
    //     """
    //     self.only_owner()
    //     assert min_bet_amount.native > 0, "min bet amount must be greater than 0"
    //     assert (
    //         min_bet_amount.native <= self.max_bet_amount
    //     ), "min bet amount must be less than max bet amount"
    //     self.min_bet_amount = min_bet_amount.native
    // 
    // @arc4.abimethod
    // def set_max_bet_amount(self, max_bet_amount: arc4.UInt64) -> None:
    //     """
    //     Set the maximum bet amount
    //     """
    //     self.only_owner()
    //     assert max_bet_amount.native > 0, "max bet amount must be greater than 0"
    //     assert (
    //         max_bet_amount.native >= self.min_bet_amount
    //     ), "max bet amount must be greater than min bet amount"
    //     self.max_bet_amount = max_bet_amount.native
    // 
    // # block seed utils
    // 
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    //     return op.Block.blk_seed(round)[-32:]
    // 
    // # bankroll management
    // 
    // @arc4.abimethod
    // def deposit(self) -> None:
    //     """
    //     Deposit funds into the contract
    //     """
    //     payment = require_payment(Txn.sender)
    //     assert payment > 0, "payment must be greater than 0"
    //     self.balance_total += payment
    //     self.balance_available += payment
    // 
    // @arc4.abimethod
    // def withdraw(self, amount: arc4.UInt64) -> None:
    //     """
    //     Withdraw funds from the contract
    //     Only callable by contract owner
    // 
    //     Args:
    //         amount: The amount of funds to withdraw in atomic units
    //     """
    //     self.only_owner()
    //     assert amount.native > UInt64(0), "amount must be greater than 0"
    //     assert amount.native <= self.balance_available, "insufficient balance"
    //     itxn.Payment(receiver=Txn.sender, amount=amount.native).submit()
    //     self.balance_available -= amount.native
    //     self.balance_total -= amount.native
    // 
    // # bet key utils
    // 
    // @arc4.abimethod
    // def get_bet_key(
    //     self,
    //     address: arc4.Address,
    //     amount: arc4.UInt64,
    //     round: arc4.UInt64,
    //     index: arc4.UInt64,
    // ) -> Bytes56:
    //     return Bytes56.from_bytes(
    //         self._get_bet_key(address.native, amount.native, round.native, index.native)
    //     )
    // 
    // @subroutine
    // def _get_bet_key(
    //     self, address: Account, amount: UInt64, round: UInt64, index: UInt64
    // ) -> Bytes:
    //     return (
    //         arc4.Address(address).bytes
    //         + arc4.UInt64(amount).bytes
    //         + arc4.UInt64(round).bytes
    //         + arc4.UInt64(index).bytes
    //     )
    // 
    // # terminal methods
    // 
    // @arc4.abimethod(allow_actions=[OnCompleteAction.DeleteApplication])
    // def kill(self) -> None:
    //     """
    //     Kill the contract
    //     """
    //     assert Txn.sender == self.upgrader, "must be upgrader"
    //     assert self.updatable == UInt64(1), "not approved"
    //     assert self.balance_locked == UInt64(0), "balance locked must be 0"
    //     arc4.emit(Closed(arc4.Address(self.upgrader), arc4.Address(self.upgrader)))
    //     close_offline_on_delete(self.upgrader)
    // 
    // # slot machine methods
    // 
    // # @arc4.abimethod
    // # def spin(
    // #     self,
    // #     bet_amount: arc4.UInt64,
    // #     index: arc4.UInt64,
    // # ) -> Bytes56:
    // #     """
    // #     Spin the slot machine. Outcome is determined by the seed
    // #     of future round.
    // 
    // #     Args:
    // #         bet (uint): The player's wager.
    // #         index (uint): Player's choice of index.
    // 
    // #     Returns:
    // #         r (uint): The round number of the spin.
    // #     """
    // #     return Bytes56.from_bytes(self._spin(bet_amount.native, index.native))
    // 
    // # override
    // @subroutine
    // def _spin(self, bet_amount: UInt64, index: UInt64) -> Bytes:
    //     """
    //     Spin the slot machine. Outcome is determined by the seed
    //     of future round.
    // 
    //     Args:
    //         bet (uint): The player's wager.
    //         index (uint): Player's choice of index.
    // 
    //     Returns:
    //         r (uint): The round number of the spin.
    //     """
    //     assert bet_amount >= self.min_bet_amount, "bet amount too small"
    //     assert bet_amount <= self.max_bet_amount, "bet amount too large"
    //     payment = require_payment(Txn.sender)
    //     assert payment >= bet_amount, "payment insufficient"
    //     extra_payment = payment - bet_amount
    //     assert (
    //         extra_payment >= BOX_COST_BET
    //     ), "extra payment must be greater than box cost"
    //     assert (
    //         extra_payment <= MAX_EXTRA_PAYMENT
    //     ), "extra payment must be less than max extra payment"
    //     # Update balance tracking
    //     #   Add bet amount to total balance
    //     self.balance_total += bet_amount
    //     self.balance_available += bet_amount  # Add bet amount to available first
    //     max_possible_payout = bet_amount * UInt64(MAX_PAYOUT_MULTIPLIER)
    //     self.balance_locked += max_possible_payout
    //     self.balance_available -= max_possible_payout
    //     # Create bet
    //     round = Global.round
    //     bet_key = self._get_bet_key(Txn.sender, bet_amount, round, index)
    //     assert bet_key not in self.bet, "bet already exists"
    //     claim_round = round + ROUND_FUTURE_DELTA
    //     self.bet[bet_key] = Bet(
    //         who=arc4.Address(Txn.sender),
    //         amount=arc4.UInt64(bet_amount),
    //         confirmed_round=arc4.UInt64(round),
    //         index=arc4.UInt64(index),
    //         claim_round=arc4.UInt64(claim_round),
    //     )
    //     arc4.emit(
    //         BetPlaced(
    //             who=arc4.Address(Txn.sender),
    //             amount=arc4.UInt64(bet_amount),
    //             confirmed_round=arc4.UInt64(round),
    //             index=arc4.UInt64(index),
    //             claim_round=arc4.UInt64(claim_round),
    //         )
    //     )
    //     return bet_key
    // 
    // # @arc4.abimethod
    // # def claim(self, bet_key: Bytes56) -> arc4.UInt64:
    // #     """
    // #     Claim a bet
    // 
    // #     Args:
    // #         bet_key: The key of the bet to claim
    // 
    // #     Returns:
    // #         payout: The payout for the bet
    // #     """
    // #     return arc4.UInt64(self._claim(bet_key.bytes))
    // 
    // # override
    // @subroutine
    // def _claim(self, bet_key: Bytes) -> UInt64:
    //     """
    //     Claim a bet
    //     Args:
    //         bet_key: The key of the bet to claim
    // 
    //     Returns:
    //         payout: The payout for the bet
    //     """
    //     assert bet_key in self.bet, "bet not found"
    frame_dig -1
    box_len
    bury 1
    // src/src/contract.py:560
    // assert bet_key in self.bet, "bet not found"
    assert // bet not found
    // src/src/contract.py:561
    // bet = self.bet[bet_key].copy()
    frame_dig -1
    box_get
    swap
    dup
    uncover 2
    assert // check self.bet entry exists
    // src/src/contract.py:562-564
    // # if round is greater than claim_round + MAX_CLAIM_ROUND_DELTA, the bet is expired
    // # and we can return the box cost to the sender
    // if Global.round > bet.claim_round.native + MAX_CLAIM_ROUND_DELTA:
    global Round
    swap
    extract 56 8 // on error: Index access is out of bounds
    dup
    cover 2
    btoi
    dup
    cover 2
    int 1000
    +
    >
    bz _claim_else_body@3
    // src/src/contract.py:565
    // del self.bet[bet_key]
    frame_dig -1
    box_del
    pop
    // src/src/contract.py:566-568
    // # Update balance tracking
    // #   Release locked balance and adjust available balance
    // max_possible_payout = bet.amount.native * UInt64(MAX_PAYOUT_MULTIPLIER)
    frame_dig 3
    dup
    extract 32 8 // on error: Index access is out of bounds
    dup
    btoi
    int 100
    *
    // src/src/contract.py:569
    // self.balance_locked -= max_possible_payout
    int 0
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:569
    // self.balance_locked -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    -
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:569
    // self.balance_locked -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:570
    // self.balance_available += max_possible_payout
    int 0
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:570
    // self.balance_available += max_possible_payout
    app_global_get_ex
    assert // check self.balance_available exists
    +
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:570
    // self.balance_available += max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:571
    // itxn.Payment(receiver=Txn.sender, amount=BOX_COST_BET).submit()
    itxn_begin
    txn Sender
    int 37700
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:574
    // who=bet.who,
    dig 1
    extract 0 32 // on error: Index access is out of bounds
    swap
    // src/src/contract.py:576
    // confirmed_round=bet.confirmed_round,
    dig 2
    extract 40 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:577
    // index=bet.index,
    uncover 3
    extract 48 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:573-580
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=arc4.UInt64(0),
    // )
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig 4
    concat
    // src/src/contract.py:579
    // payout=arc4.UInt64(0),
    byte 0x0000000000000000
    // src/src/contract.py:573-580
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=arc4.UInt64(0),
    // )
    concat
    // src/src/contract.py:572-581
    // arc4.emit(
    //     BetClaimed(
    //         who=bet.who,
    //         amount=bet.amount,
    //         confirmed_round=bet.confirmed_round,
    //         index=bet.index,
    //         claim_round=bet.claim_round,
    //         payout=arc4.UInt64(0),
    //     )
    // )
    method "BetClaimed(address,uint64,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:582
    // return UInt64(0)
    int 0
    frame_bury 0
    retsub

_claim_else_body@3:
    // src/src/contract.py:586-587
    // # calculate r from block seed and bet key
    // combined = self._get_block_seed(bet.claim_round.native) + bet_key
    frame_dig 5
    callsub _get_block_seed
    frame_dig -1
    concat
    // src/src/contract.py:588
    // hashed = op.sha256(combined)
    sha256
    // src/src/contract.py:591
    // arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    byte 0x3b9aca00
    b%
    // src/src/contract.py:590-592
    // arc4.UInt256(
    //     arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    // ).bytes[-8:]
    dup
    len
    int 32
    <=
    assert // overflow
    int 32
    bzero
    b|
    dup
    len
    int 8
    dig 1
    >=
    int 8
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    // src/src/contract.py:589-593
    // r = arc4.UInt64.from_bytes(
    //     arc4.UInt256(
    //         arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    //     ).bytes[-8:]
    // )
    swap
    // src/src/contract.py:590-592
    // arc4.UInt256(
    //     arc4.UInt256.from_bytes(hashed).native % BigUInt(1_000_000_000)
    // ).bytes[-8:]
    substring3
    // src/src/contract.py:594-604
    // #########################################################
    // # get payout internal if subclass of SlotMachinePayoutModel
    // # otherwise call model to get payout
    // #########################################################
    // # payout = ar4.ab self._calculate_bet_payout(bet.amount.native, r)
    // payout, txn = arc4.abi_call(
    //     SlotMachinePayoutModelInterface.get_payout,
    //     bet.amount,
    //     r,
    //     app_id=Application(self.payout_model),
    // )
    itxn_begin
    // src/src/contract.py:601
    // bet.amount,
    frame_dig 3
    extract 32 8 // on error: Index access is out of bounds
    dup
    frame_bury 1
    // src/src/contract.py:603
    // app_id=Application(self.payout_model),
    int 0
    // src/src/contract.py:330
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    // src/src/contract.py:603
    // app_id=Application(self.payout_model),
    app_global_get_ex
    assert // check self.payout_model exists
    itxn_field ApplicationID
    // src/src/contract.py:594-604
    // #########################################################
    // # get payout internal if subclass of SlotMachinePayoutModel
    // # otherwise call model to get payout
    // #########################################################
    // # payout = ar4.ab self._calculate_bet_payout(bet.amount.native, r)
    // payout, txn = arc4.abi_call(
    //     SlotMachinePayoutModelInterface.get_payout,
    //     bet.amount,
    //     r,
    //     app_id=Application(self.payout_model),
    // )
    method "get_payout(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    int appl
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dup
    cover 3
    frame_bury 0
    extract 0 4
    byte 0x151f7c75
    ==
    assert // ARC4 prefix is valid
    // src/src/contract.py:605-608
    // #########################################################
    // # Update balance tracking
    // #   Release locked balance and adjust available balance
    // max_possible_payout = bet.amount.native * UInt64(MAX_PAYOUT_MULTIPLIER)
    btoi
    int 100
    *
    // src/src/contract.py:609
    // self.balance_locked -= max_possible_payout
    int 0
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:609
    // self.balance_locked -= max_possible_payout
    app_global_get_ex
    assert // check self.balance_locked exists
    dig 1
    -
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    // src/src/contract.py:609
    // self.balance_locked -= max_possible_payout
    swap
    app_global_put
    // src/src/contract.py:610
    // self.balance_available += (
    int 0
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:610
    // self.balance_available += (
    app_global_get_ex
    assert // check self.balance_available exists
    // src/src/contract.py:611
    // max_possible_payout - payout.native
    dig 2
    btoi
    dup
    frame_bury 2
    uncover 2
    dig 1
    -
    // src/src/contract.py:610-612
    // self.balance_available += (
    //     max_possible_payout - payout.native
    // )  # Release locked funds minus payout
    uncover 2
    +
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    // src/src/contract.py:610-612
    // self.balance_available += (
    //     max_possible_payout - payout.native
    // )  # Release locked funds minus payout
    swap
    app_global_put
    // src/src/contract.py:613
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    int 0
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:613
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    app_global_get_ex
    assert // check self.balance_total exists
    swap
    -
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    // src/src/contract.py:613
    // self.balance_total -= payout.native  # Reduce total balance by payout amount
    swap
    app_global_put
    // src/src/contract.py:614
    // if payout > 0:
    byte 0x0000000000000000
    b>
    bz _claim_after_if_else@7
    // src/src/contract.py:615
    // itxn.Payment(receiver=bet.who.native, amount=payout.native).submit()
    itxn_begin
    frame_dig 3
    extract 0 32 // on error: Index access is out of bounds
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit

_claim_after_if_else@7:
    // src/src/contract.py:616
    // del self.bet[bet_key]
    frame_dig -1
    box_del
    pop
    // src/src/contract.py:617
    // itxn.Payment(receiver=Txn.sender, amount=BOX_COST_BET).submit()
    itxn_begin
    txn Sender
    int 37700
    itxn_field Amount
    itxn_field Receiver
    int pay
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    itxn_submit
    // src/src/contract.py:620
    // who=bet.who,
    frame_dig 3
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    // src/src/contract.py:622
    // confirmed_round=bet.confirmed_round,
    dup
    extract 40 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:623
    // index=bet.index,
    extract 48 8 // on error: Index access is out of bounds
    cover 2
    // src/src/contract.py:619-626
    // BetClaimed(
    //     who=bet.who,
    //     amount=bet.amount,
    //     confirmed_round=bet.confirmed_round,
    //     index=bet.index,
    //     claim_round=bet.claim_round,
    //     payout=payout,
    // )
    frame_dig 1
    concat
    swap
    concat
    swap
    concat
    frame_dig 4
    concat
    frame_dig 0
    concat
    // src/src/contract.py:618-627
    // arc4.emit(
    //     BetClaimed(
    //         who=bet.who,
    //         amount=bet.amount,
    //         confirmed_round=bet.confirmed_round,
    //         index=bet.index,
    //         claim_round=bet.claim_round,
    //         payout=payout,
    //     )
    // )
    method "BetClaimed(address,uint64,uint64,uint64,uint64,uint64)"
    swap
    concat
    log
    // src/src/contract.py:628
    // return payout.native
    frame_dig 2
    frame_bury 0
    retsub


// contract.SlotMachine._get_block_seed(round: uint64) -> bytes:
_get_block_seed:
    // src/src/contract.py:390-391
    // @subroutine
    // def _get_block_seed(self, round: UInt64) -> Bytes:
    proto 1 1
    // src/src/contract.py:392
    // return op.Block.blk_seed(round)[-32:]
    frame_dig -1
    block BlkSeed
    dup
    len
    int 32
    dig 1
    >=
    int 32
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    swap
    substring3
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.set_version(contract_version: bytes, deployment_version: bytes) -> void:
set_version:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:83-86
    // @arc4.abimethod
    // def set_version(
    //     self, contract_version: arc4.UInt64, deployment_version: arc4.UInt64
    // ) -> None:
    proto 2 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:87
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:87
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:88
    // arc4.emit(VersionUpdated(contract_version, deployment_version))
    frame_dig -2
    frame_dig -1
    concat
    method "VersionUpdated(uint64,uint64)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:89
    // self.contract_version = contract_version.native
    frame_dig -2
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:89
    // self.contract_version = contract_version.native
    swap
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:90
    // self.deployment_version = deployment_version.native
    frame_dig -1
    btoi
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:90
    // self.deployment_version = deployment_version.native
    swap
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.approve_update(approval: bytes) -> void:
approve_update:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:101-102
    // @arc4.abimethod
    // def approve_update(self, approval: arc4.Bool) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:103
    // assert Txn.sender == self.owner, "must be owner"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:103
    // assert Txn.sender == self.owner, "must be owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // must be owner
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:104
    // arc4.emit(UpdateApproved(arc4.Address(self.owner), approval))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:104
    // arc4.emit(UpdateApproved(arc4.Address(self.owner), approval))
    app_global_get_ex
    assert // check self.owner exists
    frame_dig -1
    concat
    method "UpdateApproved(address,bool)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:105
    // self.updatable = approval.native
    frame_dig -1
    int 0
    getbit
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:105
    // self.updatable = approval.native
    swap
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.grant_upgrader(upgrader: bytes) -> void:
grant_upgrader:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:107-108
    // @arc4.abimethod
    // def grant_upgrader(self, upgrader: arc4.Address) -> None:
    proto 1 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:109
    // assert Txn.sender == Global.creator_address, "must be creator"
    txn Sender
    global CreatorAddress
    ==
    assert // must be creator
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:110
    // arc4.emit(UpgraderGranted(arc4.Address(self.upgrader), upgrader))
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:110
    // arc4.emit(UpgraderGranted(arc4.Address(self.upgrader), upgrader))
    app_global_get_ex
    assert // check self.upgrader exists
    frame_dig -1
    concat
    method "UpgraderGranted(address,address)"
    swap
    concat
    log
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:111
    // self.upgrader = upgrader.native
    frame_dig -1
    app_global_put
    retsub


// opensubmarine.contracts.update.Upgradeable.contract.Upgradeable.on_update() -> void:
on_update:
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:92-93
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def on_update(self) -> None:
    proto 0 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:94-97
    // ##########################################
    // # WARNING: This app can be updated by the creator
    // ##########################################
    // assert Txn.sender == self.upgrader, "must be upgrader"
    txn Sender
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:94-97
    // ##########################################
    // # WARNING: This app can be updated by the creator
    // ##########################################
    // assert Txn.sender == self.upgrader, "must be upgrader"
    app_global_get_ex
    assert // check self.upgrader exists
    ==
    assert // must be upgrader
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:98
    // assert self.updatable == UInt64(1), "not approved"
    int 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:98
    // assert self.updatable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.updatable exists
    int 1
    ==
    assert // not approved
    retsub


// contract.Deleteable.on_delete() -> void:
on_delete:
    // src/src/contract.py:57-58
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    // def on_delete(self) -> None:  # pragma: no cover
    proto 0 0
    // src/src/contract.py:59-62
    // ##########################################
    // # WARNING: This app can be deleted by the creator (Development)
    // ##########################################
    // assert Txn.sender == Global.creator_address, "must be creator"
    txn Sender
    global CreatorAddress
    ==
    assert // must be creator
    // src/src/contract.py:63
    // assert self.deletable == UInt64(1), "not approved"
    int 0
    // src/src/contract.py:43
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:63
    // assert self.deletable == UInt64(1), "not approved"
    app_global_get_ex
    assert // check self.deletable exists
    int 1
    ==
    assert // not approved
    retsub


// contract.SlotMachine.__init__() -> void:
__init__:
    // src/src/contract.py:314
    // def __init__(self) -> None:
    proto 0 0
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/access/Ownable/contract.py:20
    // self.owner = Account()
    byte "owner"
    // src/src/contract.py:315-316
    // # ownable state
    // self.owner = Global.creator_address  # set owner to creator
    global CreatorAddress
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:31
    // self.contract_version = UInt64()
    byte "contract_version"
    // src/src/contract.py:317-318
    // # upgradable state
    // self.contract_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:32
    // self.deployment_version = UInt64()
    byte "deployment_version"
    // src/src/contract.py:319
    // self.deployment_version = UInt64()
    int 0
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:33
    // self.updatable = bool(1)
    byte "updatable"
    // src/src/contract.py:320
    // self.updatable = bool(1)
    int 1
    app_global_put
    // usr/local/lib/python3.12/site-packages/opensubmarine/contracts/update/Upgradeable/contract.py:34
    // self.upgrader = Account()
    byte "upgrader"
    // src/src/contract.py:321
    // self.upgrader = Global.creator_address
    global CreatorAddress
    app_global_put
    // src/src/contract.py:43
    // self.deletable = bool(1)
    byte "deletable"
    // src/src/contract.py:322-323
    // # deleteable state
    // self.deletable = bool(1)
    int 1
    app_global_put
    // src/src/contract.py:324-325
    // # slot machine state
    // self.balance_total = UInt64()
    byte "balance_total"
    int 0
    app_global_put
    // src/src/contract.py:326
    // self.balance_available = UInt64()
    byte "balance_available"
    int 0
    app_global_put
    // src/src/contract.py:327
    // self.balance_locked = UInt64()
    byte "balance_locked"
    int 0
    app_global_put
    // src/src/contract.py:328
    // self.min_bet_amount = UInt64(MIN_BET_AMOUNT)  # 1 VOI
    byte "min_bet_amount"
    int 1000000
    app_global_put
    // src/src/contract.py:329
    // self.max_bet_amount = UInt64(MAX_BET_AMOUNT)  # 1000 VOI
    byte "max_bet_amount"
    int 1000000000
    app_global_put
    // src/src/contract.py:330
    // self.payout_model = UInt64()  # app id of payout model
    byte "payout_model"
    int 0
    app_global_put
    retsub
